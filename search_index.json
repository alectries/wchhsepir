[["index.html", "In-Service Presentation, August 2024 About Sections", " In-Service Presentation, August 2024 Alec Higgins August 1, 2024 About This presentation was developed by Alec Higgins for the Epidemiology Program at Wake County Health and Human Services (WCHHS) as part of a practicum supported by the University of North Carolina (UNC) Gillings School of Global Public Health. It also serves as a portfolio of work done for the Epidemiology Program during the practicum. The presentation is given in a book format, generated in R, both as a demonstration of Bookdown’s capabilities and as a more convenient reference for future use. Thanks to Morgan Poole, Akanksha Acharya, Marlene Kurt, and Katie LaWall for their support throughout this practicum. Sections This presentation is organized by project, so R methods can be seen in the context of their uses. The following sections are included in the presentation: 2024 CD Report: This section demonstrates the code used to standardize, condense, and export data generated for WCHHS’ 2024 Communicable Disease Report. It primarily uses R scripts but includes some R Markdown to generate the tables. 2024 MCH Report: This section shows the code used to generate simple graphics for WCHHS’ 2024 Maternal and Child Health Report. It uses an R script and R Markdown. STI: This section demonstrates the import, processing, and classification of line list data on sexually transmitted infection (STIs) with graphics generated from the data. It is written entirely in R Markdown. Respiratory Viruses: This section walks through the code used to automate the regular development of a PowerPoint presentation, with graphics, from line list data exported from NC DETECT. It is written in R Markdown to generate a Quarto presentation (in PowerPoint format). Bookdown: The final section is a foray into the meta with a brief explanation of this presentation format itself. "],["cd-report.html", "Section 1 2024 CD Report 1.1 Libraries 1.2 Settings 1.3 Reading data, then saving 1.4 Combining and saving data 1.5 Extracting and exporting demographic data from a line list 1.6 Tabulating demographic data 1.7 Calculating incidence by ZIP code 1.8 Generating counts and rates tables 1.9 Final notes", " Section 1 2024 CD Report WCHHS publishes an annual Communicable Disease Report, which displays trends, demographics, and key insights for the top 10 communicable diseases and includes spotlight sections to explain the role of public health, prevention topics, and intervention programs in Wake County. For this report, I contributed data analysis, graphics, and several tables. The graphics were produced in Microsoft Excel. The R code used to manage and tidy the data and to generate the table are shown below. We will start by going through the import.R script, then look through the other two scripts and the table-generating R Markdown file. 1.1 Libraries # Libraries # These commands must be run first! # Highlight them and press Ctrl + Enter (Cmd + Enter on Mac) library(tidyverse) library(readxl) There are two non-standard libraries used in these scripts. tidyverse: The tidyverse is a set of packages with a common syntax and philosophy. It includes many useful packages, such as dplyr (which provides many data management functions) and ggplot2 (which is used to create all graphics in this presentation). readxl: This package provides functions that read Microsoft Excel files. 1.2 Settings # Settings ## Set the years of interest for this report here: years &lt;- list(2023, 2022, 2021, 2020, 2019) # Functions ## Function to implement year setting sesh_cyear &lt;- function(x){paste0(&quot;c&quot;, x)} sesh_ryear &lt;- function(x){paste0(&quot;r&quot;, x)} A list of years of interest and two simple functions are created here. Note a few things: The lines beginning with #, which are comments and are not run. &lt;-: The assignment arrow in the first expression, which says define years to be a list with values 2023, 2022, …. function(x){...}: These lines assign a function with one argument (x) to sesh_cyear and sesh_ryear. These functions are very simple: they paste a letter (c or r) in front of the argument and output it. We’ll see why this is used soon. As a note: When writing your own functions, the names are entirely up to you. However, it is best practice to avoid writing a function and giving it the same name as another function in a package you’re using. I use the sesh_ prefix to avoid overwriting any pre-existing functions, but that’s my own convention. 1.3 Reading data, then saving ## Read and save in R preferred format read_csv(&quot;Tables/Notifiables.csv&quot;) %&gt;% saveRDS(file = &quot;Tables/notifiables.rds&quot;) read_csv(&quot;Tables/NCNotifiables.csv&quot;) %&gt;% saveRDS(&quot;Tables/ncnotifiables.rds&quot;) These lines read a .csv file with data, then save it as a .rds file, which is a standard R format that can be read faster and more easily than spreadsheets. Notice: read_csv(): This reads the specified .csv file. saveRDS(): This saves the data specified as a .rds file. Pipe %&gt;%: The pipe is a shorthand function that takes the output of the function before it and inserts it as the first argument in the next line. Alternatively, these lines could be written: saveRDS( read_csv(&quot;Tables/Notifiables.csv&quot;), file = &quot;Tables/notifiables.rds&quot; ) saveRDS( read_csv(&quot;Tables/NCNotifiables.csv&quot;), file = &quot;Tables/ncnotifiables.rds&quot; ) While both options perform the same task, the first is more logical. This becomes important when you want to string several steps together: the pipe allows you to order functions in the order you want to perform them rather than nesting the first step within each of the following steps. 1.4 Combining and saving data First, we define two functions to read the data we just saved. This will save a few keystrokes as we go. You’ll notice there are no arguments specified, because we do not need any: we just want to have a shorthand way of saying “read the notif data” and “read the ncnotif data”. notif &lt;- function(){readRDS(&quot;Tables/notifiables.rds&quot;)} ncnotif &lt;- function(){readRDS(&quot;Tables/ncnotifiables.rds&quot;)} Next, we actually read in the data, manipulate it to make it easier to combine, combine it with other data, pivot it to be more readable again, and save it to a .csv file for use later. Look for the comments within to explain the code. # Join the Wake County notifiables data with the North Carolina notifiables data. full_join( # Join the Wake County counts with the Wake County rates. full_join( pivot_longer( ## Condense the counts by year columns. notif(), ## Read in the Wake County data. cols = years %&gt;% lapply(sesh_cyear) %&gt;% unlist(), ## Insert a &quot;c&quot; before the year for count columns. names_to = &quot;cyear&quot;, values_to = &quot;cases&quot; ) %&gt;% mutate(year = as.numeric(str_remove(cyear, &quot;c&quot;))), ## Remove the &quot;c&quot; and make the year a number. pivot_longer( ## Repeat, but for rates. notif(), cols = years %&gt;% lapply(sesh_ryear) %&gt;% unlist(), names_to = &quot;ryear&quot;, values_to = &quot;rate&quot; ) %&gt;% mutate(year = as.numeric(str_remove(ryear, &quot;r&quot;))), by = join_by(disease, year) ## Merge counts/rates by disease name and year. ) %&gt;% mutate(loc = &quot;Wake County&quot;) %&gt;% ## Specify these are Wake numbers. select(c(disease, year, loc, cases, rate)), ## Delete all but five columns. # Join the North Carolina counts with the North Carolina rates. full_join( pivot_longer( ncnotif(), cols = years %&gt;% lapply(sesh_cyear) %&gt;% unlist(), names_to = &quot;cyear&quot;, values_to = &quot;cases&quot; ) %&gt;% mutate(year = as.numeric(str_remove(cyear, &quot;c&quot;))), pivot_longer( ncnotif(), cols = years %&gt;% lapply(sesh_ryear) %&gt;% unlist(), names_to = &quot;ryear&quot;, values_to = &quot;rate&quot; ) %&gt;% mutate(year = as.numeric(str_remove(ryear, &quot;r&quot;))), by = join_by(disease, year) ) %&gt;% mutate(loc = &quot;North Carolina&quot;) %&gt;% select(c(disease, year, loc, cases, rate)), join_by(disease, year, loc, cases, rate) # Merge Wake County and NC data with these variables. ) %&gt;% # The Wake and NC notifiables data are piped ahead here. # This is the end of the first full_join. # Split the Wake and NC data into two columns. pivot_wider( id_cols = c(disease, year), names_from = loc, values_from = rate ) %&gt;% # Save the new data to a .csv file. write_csv(&quot;Products/Counts/all.csv&quot;, na = &quot;&quot;) Here are the steps performed above: Separately, select counts columns and rates columns from Notifiables.rds and NCNotifiables.rds. Pivot them, so columns named by year become year values in a “Year” column, with new “Counts” and “Rates” columns for their data. This creates more rows than there originally were. Join the counts and rates tables, so they appear in the same table. Mutate, or add, a location column in each, specifying whether the values apply to Wake County or North Carolina. Join the Wake County and North Carolina tables, so they appear in the same table. Pivot the combined table, so there are rates columns by location containing yearly values. Save the combined data as a .csv file. 1.5 Extracting and exporting demographic data from a line list The final section of the import.R script takes line lists (for foodborne, vaccine-preventable, vector-borne, and sexually transmitted illnesses), extracts the columns with age, sex, race, ethnicity, and ZIP code data, and exports them to a separate file for analysis later. First, we need to write a function that automates the selection of just those five columns from the data. Here, that function is sesh_caseimport. ## function to automate selection of key demographic data sesh_caseimport &lt;- function(x){ tibble( age = unlist(x[str_detect(names(x), &quot;Age&quot;)]), gender = unlist(x[str_detect(names(x), &quot;Gender&quot;)]), race = unlist(x[str_detect(names(x), &quot;Race&quot;)]), hisp = unlist(x[str_detect(names(x), &quot;Hispanic&quot;)]), zip = unlist(x[str_detect(names(x), coll(&quot;ZIP&quot;, ignore_case = TRUE))]) ) This function creates a specific kind of table (a tibble, which is a tidyverse object) with five columns, one each for the five data points we want to extract from each case. For each column, we: Use str_detect() to search the column headers, provided by names(), for five keywords. This ensures that if the column headers change between years or line lists, the same script will still work. Subset (select) the matching column from the original dataset using x[] syntax. Unlist the column found in the original, converting it to a standard vector (column in a dataset). Name the columns something standard. Here, those names are age, gender, race, hisp, and zip. For the ZIP code, we use coll() with the ignore_case = TRUE option so that the script will select “ZIP Code”, “Zip Code”, “zip code”, or any other variation. Next, we need to apply the function to several line list workbooks. For example, we do: ## condense and save data for analysis read_xlsx(&quot;Tables/Foodborne.xlsx&quot;, sheet = &quot;E Coli&quot;) %&gt;% sesh_caseimport() %&gt;% saveRDS(file = &quot;Tables/fb_ecoli.rds&quot;) This code: Reads a specific sheet (tab) of an Excel workbook. Applies sesh_caseimport to extract the needed data. Saves the extracted data as a .rds file that can be used later. This step needs to be performed several times for each sheet from which data needs to be extracted. That can be seen in import.R. Next, we move to the pre-analysis of demographic data. 1.6 Tabulating demographic data This code is in the demographics.R file. It performs three steps: Create a list of pre-generated datasets with the needed demographic data. Create three functions to classify the data, tabulate the categories, and export the new tables as .csv files. Apply the functions to the list of datasets. First, we write the list: # List # This is the list of all tables to be used with the demographics script. # This list is consistent with the tables generated by import.R. tables &lt;- list( # Foodborne diseases &quot;Tables/fb_campy.rds&quot;, &quot;Tables/fb_ecoli.rds&quot;, &quot;Tables/fb_hepa.rds&quot;, &quot;Tables/fb_salm.rds&quot;, &quot;Tables/fb_shig.rds&quot;, # Vector-borne diseases &quot;Tables/vb_deng.rds&quot;, &quot;Tables/vb_ehrl.rds&quot;, &quot;Tables/vb_ence.rds&quot;, &quot;Tables/vb_lyme.rds&quot;, &quot;Tables/vb_mala.rds&quot;, &quot;Tables/vb_rick.rds&quot;, # Vaccine-preventable diseases &quot;Tables/vp_hepaacute.rds&quot;, &quot;Tables/vp_hepbchron.rds&quot;, &quot;Tables/vp_hflu.rds&quot;, &quot;Tables/vp_pert.rds&quot;, # STIs and HIV &quot;Tables/st_chla.rds&quot;, &quot;Tables/st_gono.rds&quot;, &quot;Tables/st_hiv.rds&quot;, &quot;Tables/st_syph.rds&quot; ) Comments are included in demographics.R to make the table list easier to read, but they are not required. Next, we write the functions: # Gender function # Generates a set of tables for gender breakdown for each disease. sesh_gender &lt;- function(x){ readRDS(x) %&gt;% mutate(gender = case_when(gender == &quot;Male&quot; ~ &quot;Male&quot;, gender == &quot;Female&quot; ~ &quot;Female&quot;, is.na(gender) ~ &quot;Unknown&quot;, .default = &quot;Unknown&quot;)) %&gt;% group_by(gender) %&gt;% tally() %&gt;% spread(gender, n) %&gt;% mutate(total = rowSums(across(everything()))) %&gt;% write_csv(paste0( &quot;Products/Counts/&quot;, str_remove(x, &quot;Tables/&quot;) %&gt;% str_remove(&quot;.rds&quot;), &quot;-gender.csv&quot; )) } # Age function # Creates age categories, then generates tables for age breakdowns by disease. sesh_age &lt;- function(x){ readRDS(x) %&gt;% mutate(age_g = case_when(age &lt;= 4 ~ &quot;0-4&quot;, age &gt;= 5 &amp; age &lt;= 17 ~ &quot;5-17&quot;, age &gt;= 18 &amp; age &lt;= 24 ~ &quot;18-24&quot;, age &gt;= 25 &amp; age &lt;= 49 ~ &quot;25-49&quot;, age &gt;= 50 &amp; age &lt;= 64 ~ &quot;50-64&quot;, age &gt;= 65 ~ &quot;65+&quot;, .default = &quot;Unknown&quot;)) %&gt;% mutate(age_g = factor(age_g, levels = c(&quot;0-4&quot;, &quot;5-17&quot;, &quot;18-24&quot;, &quot;25-49&quot;, &quot;50-64&quot;, &quot;65+&quot;, &quot;Unknown&quot;))) %&gt;% group_by(age_g) %&gt;% tally() %&gt;% spread(age_g, n) %&gt;% mutate(total = rowSums(across(everything()))) %&gt;% write_csv(paste0( &quot;Products/Counts/&quot;, str_remove(x, &quot;Tables/&quot;) %&gt;% str_remove(&quot;.rds&quot;), &quot;-age.csv&quot; )) } # Race/ethnicity function # Creates race/ethnicity categories, then generates tables for race breakdowns. sesh_raceth &lt;- function(x){ readRDS(x) %&gt;% mutate(raceth = case_when(race == &quot;White&quot; ~ race, race == &quot;Black or African American&quot; ~ race, race == &quot;Asian&quot; ~ race, race == &quot;Other&quot; ~ race, race == &quot;American Indian Alaskan Native&quot; ~ &quot;Other&quot;, race == &quot;Native Hawaiian or Pacific Islander&quot; ~ &quot;Other&quot;, str_detect(race, &quot;,&quot;) ~ &quot;Two or more races&quot;, .default = &quot;Unknown&quot;)) %&gt;% mutate(raceth = factor(raceth, levels = c(&quot;Asian&quot;, &quot;Black or African American&quot;, &quot;White&quot;, &quot;Other&quot;, &quot;Two or more races&quot;, &quot;Unknown&quot;))) %&gt;% group_by(raceth) %&gt;% tally() %&gt;% spread(raceth, n) %&gt;% mutate(total = rowSums(across(everything()))) %&gt;% write_csv(paste0( &quot;Products/Counts/&quot;, str_remove(x, &quot;Tables/&quot;) %&gt;% str_remove(&quot;.rds&quot;), &quot;-raceth.csv&quot; )) } These three functions: Read the specified datasets. Mutate (create) the gender, age_g, and raceth columns with standardized categories. This uses the case_when() function, which is essentially a cleaner way of writing a series of if and else expressions. For example, race == \"White\" ~ race says “if race is equal to ‘White’, use the value from race for raceth”, and race == \"American Indian Alaskan Native\" ~ \"Other\" says “if race is equal to AIAN, use ‘Other’ as the value for raceth”. Mutate the age_g and raceth columns to be factors instead of character variables. This orders the data, which will make the exported tables more logical. Group the data using group_by(). Tally the data according to the groups (gender, age_g, or raceth). Spread the data so that the columns become the counts by group. Mutate (create) a total column. Save the data as a .csv file. This function appears complicated, but it simply removes “Tables/” and “.rds” from the listing in the original table and adds the appropriate file path and file extension. Finally, we apply these three functions to all of the listed tables: # Table generation # Apply above functions to list of tables lapply(tables, sesh_gender) lapply(tables, sesh_age) lapply(tables, sesh_raceth) Each of these functions just say “apply the sesh_... function to each item in the list tables”. This is a much faster and cleaner way of performing these three repetitive tasks than the alternative, which would be to write each of the three functions 19 times, changing the file names each time. It also allows for much more flexibility if diseases need to be added or removed from analysis. When the functions are applied, 57 tables are generated in Products/Counts/. They only contain a row of headers, which are the specified groups, and a row of counts. 1.7 Calculating incidence by ZIP code Last, in the ratesbyzip.R script, we calculate the incidence of specified diseases in each Wake County ZIP code. First, we read in exported population data from the American Community Survey: # 2022 ACS Demographic Estimates for Wake County ## Import sheet, remove extraneous data, and clean up acs &lt;- read_xlsx(&quot;Tables/ACS demographic estimates 2022 by zip code.xlsx&quot;, sheet = &quot;Data&quot;) %&gt;% mutate(&#39;ZCTA5 Age&#39; = `...1`) %&gt;% relocate(`ZCTA5 Age`) %&gt;% select(starts_with(&quot;ZCTA5&quot;)) %&gt;% rename_with(~str_remove(., &quot;ZCTA5 &quot;)) %&gt;% filter(Age %in% c(&quot;10 to 14 years&quot;, &quot;15 to 19 years&quot;, &quot;20 to 24 years&quot;, &quot;25 to 34 years&quot;, &quot;35 to 44 years&quot;, &quot;45 to 54 years&quot;, &quot;55 to 59 years&quot;, &quot;60 to 64 years&quot;, &quot;65 to 74 years&quot;, &quot;75 to 84 years&quot;, &quot;85 years and over&quot;)) %&gt;% mutate(across(!Age, ~str_remove(., &quot;,&quot;))) %&gt;% mutate(across(!Age, as.numeric)) This code imports the spreadsheet, performs some tricks (mutate, relocate, select, and rename_with) to select just the necessary columns, filters to select just the rows with populations vulnerable to STIs, and mutates the columns with population values to become numeric (without the included comma separators). Next, we total the populations across selected age groups and pivot the data so that each row is a ZIP code and a total vulnerable population: ## Total age groups &gt;= 10 and pivot popbyzip &lt;- acs %&gt;% summarise(across(where(is.numeric), ~sum(., na.rm = TRUE))) %&gt;% pivot_longer(everything(), names_to = &quot;ZIP&quot;, values_to = &quot;Population&quot;) Then, we list the tables of real data we want to work with, similar to demographics.R: # List ## List line list tables for mapping tables &lt;- list( # STDs and HIV &quot;Tables/st_chla.rds&quot;, &quot;Tables/st_gono.rds&quot;, &quot;Tables/st_hiv.rds&quot;, &quot;Tables/st_syph.rds&quot; ) Then, we create a function that calculates the incidence in each ZIP code: # Rate by ZIP function ## Creates tables to calculate rates from counts and populations sesh_ratebyzip &lt;- function(x){ readRDS(x) %&gt;% mutate(allZIP = as.numeric( substr(as.character(zip), 1, 5) )) %&gt;% mutate(ZIP = case_when(allZIP %in% popbyzip$ZIP ~ allZIP, .default = 0)) %&gt;% group_by(ZIP) %&gt;% tally() %&gt;% spread(ZIP, n) %&gt;% pivot_longer(everything(), names_to = &quot;ZIP&quot;, values_to = &quot;Cases&quot;) %&gt;% mutate(ZIP = as.numeric(ZIP)) %&gt;% right_join(popbyzip %&gt;% mutate(ZIP = as.numeric(ZIP)) %&gt;% add_row(ZIP = 0, Population = NA), by = join_by(ZIP)) %&gt;% mutate(&#39;Rate per 1000&#39; = case_when( ZIP == 0 ~ Cases, .default = Cases / Population * 1000 )) %&gt;% mutate(ZIP = case_when(ZIP == 0 ~ NA, .default = ZIP), `Rate per 1000` = case_when(is.na(`Rate per 1000`) ~ 0, .default = `Rate per 1000`)) %&gt;% arrange(ZIP) %&gt;% select(c(ZIP, `Rate per 1000`)) %&gt;% write_csv(paste0( &quot;Products/Rates/&quot;, str_remove(x, &quot;Tables/&quot;) %&gt;% str_remove(&quot;.rds&quot;), &quot;-ratebyzip.csv&quot; )) } This function performs the following steps: Read the specified disease’s dataset. Mutate allZIP from the zip column, removing any extra digits from the postal code (for instance, 27610-1808 becomes 27610). Mutate ZIP from allZIP, keeping the values of any ZIP code in Wake County (allZIP %in% popbyzip$ZIP) and setting any others to 0. Group, tally, and spread counts across ZIP code columns. Pivot the data so that each row is a ZIP code and a count. Mutate ZIP to be numeric for ordering purposes. Join, or merge, the population data with the case data. Mutate a new “Rate per 1000” column that calculates the incidence from cases and populations, but setting the value for “Rate per 1000” where there is no ZIP code to be the number of cases not in a Wake County ZIP. Edit the non-Wake ZIP row to have NA in the ZIP field, and edit any rows for ZIP codes with no cases to have a rate of 0. Arrange (order) the entries by ZIP code, then select just the two needed columns. Save the table in the appropriate folder. Finally, we need to apply this function to the list of tables we specified earlier, similarly to demographics.R. # Table generation ## Apply above function to list of tables lapply(tables, sesh_ratebyzip) Once this script is run, there are four exported .csv files with rates for each ZIP code and a row specifying the number of Wake cases that were not matched to a Wake ZIP code. 1.8 Generating counts and rates tables The notifiables data processed earlier is used to generate tables of counts and rates of communicable diseases for each of the last five years. To do this, R Markdown is used to create an HTML file (webpage) with each table. For the purposes of this report, those tables were exported to Microsoft Word and formatted there. To generate the counts and rates table, we need to load two libraries: tidyverse, as used before, and kableExtra, which provides some useful table formatting options. We also need to load the necessary data and make one small change: removing the “dz-” abbreviation from some disease names. library(tidyverse) library(kableExtra) notif &lt;- readRDS(&quot;../Tables/notifiables.rds&quot;) %&gt;% select(c(disease, c2019, r2019, c2020, r2020, c2021, r2021, c2022, r2022, c2023, r2023)) %&gt;% mutate(disease = str_remove(disease, &quot;dz- &quot;)) Then, we do a few setup tasks: changing an option so that any NA values will appear as two asterisks, creating a list of column headers (the final table will have a few header rows), and writing a function to generate the tables. # Change NA fill value opts &lt;- options(knitr.kable.NA = &quot;**&quot;) # Set table column names cols &lt;- c( &quot;Disease/Condition&quot;, &quot;No. of Cases&quot;, &quot;Case Rate (+)&quot;, &quot;No. of Cases&quot;, &quot;Case Rate (+)&quot;, &quot;No. of Cases&quot;, &quot;Case Rate (+)&quot;, &quot;No. of Cases&quot;, &quot;Case Rate (+)&quot;, &quot;No. of Cases&quot;, &quot;Case Rate (+)&quot; ) # Create function to generate table sesh_kable &lt;- function(x, dc){ x %&gt;% full_join( read_csv(&quot;../Tables/categories.csv&quot;), by = join_by(disease) ) %&gt;% filter(category == dc) %&gt;% select(!category) %&gt;% kable( format = &quot;html&quot;, align = &quot;lcccccccccc&quot;, format.args = list(big.mark = &quot;,&quot;, scientific = FALSE), col.names = cols ) %&gt;% add_header_above( c(&quot; &quot; = 1, &quot;All Statuses (Confirmed, Probable, and Suspect)&quot; = 10) ) %&gt;% add_header_above( c(&quot;Population:&quot; = 1, &quot;1,112,795&quot; = 2, &quot;1,129,393&quot; = 2, &quot;1,152,357&quot; = 2, &quot;1,175,021&quot; = 2, &quot;data N/A&quot; = 2 ) ) %&gt;% add_header_above( c(&quot; &quot; = 1, &quot;2019&quot; = 2, &quot;2020&quot; = 2, &quot;2021&quot; = 2, &quot;2022&quot; = 2, &quot;2023&quot; = 2) ) %&gt;% kable_styling(html_font = &quot;arial&quot;, bootstrap_options = &quot;striped&quot;) } The function performs the following steps: Join (match) the notifiables data to a list of disease categories so that each category can have its own table. Filter the merged data to keep only the current category of interest (specified with the dc function argument). Select to remove the disease category column from the data. Create a table (using kable()) in HTML format. The align option sets the alignment of the data within the columns (here, the first column is left-justified and the rest are centered). The format.args option here inserts comma separators and ensures no data is in scientific notation. The col.names argument uses the cols list we specified above to set the bottom row of column headers. Add three header rows, from bottom to top. First, we add a row that clarifies what case statuses are included in the table, which is centered over the 10 rows of numbers (\"All Statuses (Confirmed, Probable, and Suspect)\" = 10). Next, we add a row that centers the annual population over each case/rate pair of columns. Then, we add the top header, which specifies the year of each pair. Last, we specify some style choices: Arial font and striped rows. We then apply these functions within an R code chunk. sesh_kable(notif, &quot;vp&quot;) For this function call, we specify the dataset we want to use (notif, loaded earlier) and the disease category we’re interested in (in this case, vaccine-preventable diseases, abbreviated \"vp\"). Because we’re working in R Markdown (and not just an R script), we are able to format a header and footnote around the table. We do that like so: ### Table 1: Vaccine-Preventable Diseases among Wake County Residents, 2019-2023 {r code chunk here} (+)Rate per 100,000 population. **Case and rate data may not be available for all diseases in preliminary reporting. -Case Rate is not calculated when counts are too low. All statuses (confirmed, probable, and suspect cases) are reported in this section. When we do this for each of the seven tables, we generate a nice-looking table in HTML that can be copied to Microsoft Word or used as-is. As an example, see the output for the 2024 Communicable Disease Report. 1.9 Final notes This wraps up the R code contributed to the 2024 Communicable Disease Report. This code is also reusable with minor edits and can be applied to future reporting cycles. See the HOW-TO.docx document in the SharePoint for more information. "],["mch-report.html", "Section 2 2024 MCH Report 2.1 Libraries 2.2 Transposing data 2.3 Importing data 2.4 Cleaning and combining data 2.5 Exporting data 2.6 Graphing data 2.7 Calculating risk ratios for early prenatal care 2.8 Final notes", " Section 2 2024 MCH Report WCHHS publishes an annual Maternal and Child Health Report, which provides information about maternal and child demographics, risk factors, morbidity, and mortality to the Wake County public, healthcare providers, and internal WCHHS programs. For this report, I contributed a bit of data analysis with graphics. The graphics and all data management was done in R, and the code is shown below. We will start by going through the import.R script, then look through the graph-generating R Markdown file. Unlike Section 1 (which relies partially on confidential data), this section was rendered with the actual data and outputs are shown as examples. The data used in this section is from the North Carolina BabyBook.1 2.1 Libraries ## libraries suppressPackageStartupMessages(library(tidyverse)) library(readxl) library(readr) There are three non-standard libraries used in this script. tidyverse: The tidyverse is a set of packages with a common syntax and philosophy. It includes many useful packages, such as dplyr (which provides many data management functions) and ggplot2 (which is used to create all graphics in this presentation). readxl: This package provides functions that read Microsoft Excel files. readr: This package is useful for customizing how you read .csv files. 2.2 Transposing data For the analysis below, it is helpful to have a way to transpose (flip the rows and columns of) data. For this script, I wrote sesh_transpose(), which transposes the data in a more consistent and useful way than R’s default t() function. Outside of the practicum, I later edited and added onto sesh_transpose() and published it in my ezepi package as ezt(), which I recommend using instead of copying this code. For this script, sesh_transpose() is sufficient. ## transposing function sesh_transpose &lt;- function(x, row_name){ counter &lt;- nrow(x) name &lt;- as.character(counter) df &lt;- tibble({{name}} := slice(x, {{counter}}) %&gt;% unlist() %&gt;% as.vector()) counter &lt;- counter - 1 repeat{ if(counter == 0){ break } else { name &lt;- as.character(counter) df &lt;- add_column( df, {{name}} := slice(x, {{counter}}) %&gt;% unlist() %&gt;% as.vector(), .before = 1 ) counter &lt;- counter - 1 } } df &lt;- df %&gt;% setNames(slice(df, 1)) %&gt;% slice(-1) %&gt;% mutate(across(everything(), as.numeric)) %&gt;% add_column( {{row_name}} := names(x)[-1], .before = 1 ) return(df) } Because ezt() is publicly available, I will not explain this function in too much detail. Briefly, this function: Sets a counter variable based on the number of rows in the dataset. Sets the first column name to be generated to the counter variable. Creates a dataset with one column, which is the bottom row of the original dataset. Decreases the counter by one. Starts a loop that grabs the last row of the remaining dataset, converts it to a column in the new dataset, and decreases the counter by one until the counter is zero. Sets the first row of the new dataset as the column headers, then removes the first row. Adds the column headers from the original dataset as the first column of the new dataset. If this function would be useful to you, I suggest installing and exploring ezepi. Instructions for installation and use can be found in the bottom section of the ezepi homepage. You can also use t(), which is included in base R. 2.3 Importing data Now, we need to import data from an Excel workbook, which was manually copied from certain BabyBook tables. We can do this using the readxl package: ## import data from Tables.xlsx pncxedu &lt;- read_xlsx(&quot;Tables.xlsx&quot;, sheet = &quot;table-5&quot;) pncxage &lt;- read_xlsx(&quot;Tables.xlsx&quot;, sheet = &quot;table-6&quot;) %&gt;% sesh_transpose(&quot;Month Prenatal Care Began&quot;) pncxmarital &lt;- read_xlsx(&quot;Tables.xlsx&quot;, sheet = &quot;table-7&quot;) pncxrace &lt;- read_xlsx(&quot;Tables.xlsx&quot;, sheet = &quot;race-table&quot;) pncxbirthweight &lt;- read_xlsx(&quot;Tables.xlsx&quot;, sheet = &quot;table-9&quot;) Notice that we transpose the table with prenatal care by age. That is because, unlike the other tables, Age is along the table’s y-axis, while month prenatal care began is along the x-axis. sesh_transpose() flips these axes, and \"Month Prenatal Care Began\" is included as an argument to set the header for the first column, which will no longer be the maternal age. 2.4 Cleaning and combining data 2.4.1 Prenatal care initiation by maternal age First, we deal with pncxage: the month prenatal care began stratified by maternal age. age &lt;- pncxage %&gt;% mutate(&quot;19 and under&quot; = rowSums(select(., `14`, `15`, `16`, `17`, `18`, `19`)), &quot;20 through 24&quot; = rowSums(select(., `20`, `21`, `22`, `23`, `24`)), .before = 2) %&gt;% sesh_transpose(&quot;Age&quot;) %&gt;% mutate(&quot;Early&quot; = rowSums(select(., `First`, `Second`, `Third`)), &quot;Not Early&quot; = rowSums(select(., `Fourth`, `Fifth`, `Sixth`, `Seventh`, `Eighth`, `Ninth`, `None`)), .before = 2) %&gt;% select(Age, Early, `Not Early`, `Not Stated`) %&gt;% slice(1, 2, 14:19) %&gt;% mutate(&quot;Total&quot; = rowSums(across(where(is.numeric))), &quot;Risk&quot; = Early/Total) This block of code performs the following tasks: Mutate (create) a column for births where the mother was 19 years old or under by summing the counts for age 14-19 and a column for births where the mother was 20 through 24 by summing those counts. Transpose the dataset again, so maternal age is now on the y-axis and month prenatal care began is on the x-axis. Mutate (create) a column for early prenatal care (initiated in the first trimester) and a column for not early (initiated after the first trimester or not initiated), summing the respective month columns. Select just the maternal age, early and not early counts, and not stated columns, removing the columns with individual months when prenatal care was initiated. Slice (select by their number) the rows with the age groupings of interest. Mutate (create) a Total and Risk column for early prenatal care initiation. The output of this code is shown below. Age Early Not Early Not Stated Total Risk 19 and under 144 164 0 308 0.4675325 20 through 24 806 571 10 1387 0.5811103 25 through 29 2158 917 10 3085 0.6995138 30 through 34 3942 1033 6 4981 0.7914073 35 through 39 2172 607 7 2786 0.7796123 40 through 44 450 145 0 595 0.7563025 45 or older 35 12 0 47 0.7446809 Not Stated 0 1 0 1 0.0000000 2.4.2 Prenatal care initiation by maternal education Next, we deal with pncxedu. This is performed very similarly to maternal age, but with slightly fewer steps. edu &lt;- pncxedu %&gt;% sesh_transpose(&quot;Education&quot;) %&gt;% mutate(&quot;Early&quot; = rowSums(select(., `First`, `Second`, `Third`)), &quot;Not Early&quot; = rowSums(select(., `Fourth`, `Fifth`, `Sixth`, `Seventh`, `Eighth`, `Ninth`, `None`)), .before = 2) %&gt;% select(Education, Early, `Not Early`, `Not Stated`) %&gt;% mutate(&quot;Total&quot; = rowSums(across(where(is.numeric))), &quot;Risk&quot; = Early/Total) For education, we do not need to define new categories for education level and remove extraneous ones, so this function is simpler. The output is shown below: Education Early Not Early Not Stated Total Risk Less than High School 582 547 2 1131 0.5145889 High School Graduate or GED 1019 701 12 1732 0.5883372 Some College 1782 847 8 2637 0.6757679 Bachelors Degree 3581 804 7 4392 0.8153461 Masters or PhD 2704 508 4 3216 0.8407960 Unknown 39 43 0 82 0.4756098 2.4.3 Prenatal care initiation by marital status Next is pncxmarital. Like pncxedu, this is much simpler. Here is the code: marital &lt;- pncxmarital %&gt;% sesh_transpose(&quot;Marital Status&quot;) %&gt;% mutate(&quot;Early&quot; = rowSums(select(., `First`, `Second`, `Third`)), &quot;Not Early&quot; = rowSums(select(., `Fourth`, `Fifth`, `Sixth`, `Seventh`, `Eighth`, `Ninth`, `None`)), .before = 2) %&gt;% select(`Marital Status`, Early, `Not Early`, `Not Stated`) %&gt;% mutate(&quot;Total&quot; = rowSums(across(where(is.numeric))), &quot;Risk&quot; = Early/Total) And the output: Marital Status Early Not Early Not Stated Total Risk Married 7522 1917 19 9458 0.7953056 Unmarried 2185 1529 14 3728 0.5861052 Not Stated 0 4 0 4 0.0000000 2.4.4 Prenatal care initiation by maternal race and ethnicity Now, we do pncxrace. Here is the code: race &lt;- pncxrace %&gt;% sesh_transpose(&quot;Race/Ethnicity&quot;) %&gt;% mutate(&quot;Early&quot; = rowSums(select(., `First`, `Second`, `Third`)), &quot;Not Early&quot; = rowSums(select(., `Fourth`, `Fifth`, `Sixth`, `Seventh`, `Eighth`, `Ninth`, `None`)), .before = 2) %&gt;% select(`Race/Ethnicity`, Early, `Not Early`, `Not Stated`) %&gt;% mutate(&quot;Total&quot; = rowSums(across(where(is.numeric))), &quot;Risk&quot; = Early/Total) And the output: Race/Ethnicity Early Not Early Not Stated Total Risk White/Non-Hispanic 5349 1118 11 6478 0.8257178 African American/Non-Hispanic 1634 980 6 2620 0.6236641 Other/Non-Hispanic 1254 445 5 1704 0.7359155 Hispanic 1470 907 11 2388 0.6155779 2.4.5 Birthweight by prenatal care initiation Last, we do something a bit different: we look at birthweight (in three categories) by prenatal care initiation. Here is the code: birthweight &lt;- pncxbirthweight %&gt;% sesh_transpose(&quot;Birth weight (g)&quot;) %&gt;% mutate(&quot;Early&quot; = rowSums(select(., `First`, `Second`, `Third`)), &quot;Not Early&quot; = rowSums(select(., `Fourth`, `Fifth`, `Sixth`, `Seventh`, `Eighth`, `Ninth`, `None`)), .before = 2) %&gt;% select(`Birth weight (g)`, Early, `Not Early`, `Not Stated`) %&gt;% mutate(&quot;Total&quot; = rowSums(across(where(is.numeric))), &quot;Early&quot; = Early/Total, &quot;Not Early&quot; = `Not Early`/Total, &quot;Not Stated&quot; = `Not Stated`/Total) %&gt;% select(!Total) %&gt;% pivot_longer( cols = where(is.numeric), names_to = &quot;Prenatal Care&quot;, values_to = &quot;Values&quot; ) Here is the output: Birth weight (g) Prenatal Care Values &lt;1500 Early 0.7555556 &lt;1500 Not Early 0.2444444 &lt;1500 Not Stated 0.0000000 1500-2499 Early 0.6747685 1500-2499 Not Early 0.3194444 1500-2499 Not Stated 0.0057870 &gt;=2500 Early 0.7401977 &gt;=2500 Not Early 0.2574959 &gt;=2500 Not Stated 0.0023064 Unknown Early 0.3333333 Unknown Not Early 0.6666667 Unknown Not Stated 0.0000000 This table appears different because it was pivoted: the prenatal care column names were turned into values of a new Prenatal care column, and the table was given more rows to accommodate the switch. This is useful for the specific kind of graph (a stacked bar graph) we will make with the birthweight data in a moment. 2.5 Exporting data These datasets are then exported to .csv files. ## save tables write_csv(age, &quot;Tables/age.csv&quot;) write_csv(edu, &quot;Tables/edu.csv&quot;) write_csv(marital, &quot;Tables/marital.csv&quot;) write_csv(race, &quot;Tables/race.csv&quot;) write_csv(birthweight, &quot;Tables/birthweight.csv&quot;) 2.6 Graphing data Now, we move on to graphing. These tasks are done in bar-graphs.Rmd. We want to produce five graphs: Four bar graphs showing the percent of people initiating prenatal care in the first trimester at each age group, education level, marital status, and race/ethnicity group. One stacked bar graph showing the percent of births in each birthweight class receiving early prenatal care, non-early prenatal care, or not stated. 2.6.1 Prenatal care initiation by maternal age # Read the age.csv dataset read_csv(&quot;Tables/age.csv&quot;, show_col_types = FALSE) %&gt;% # Add a Risk column for the percent in each age group receiving early care mutate(Risk = round(Risk * 100, 1)) %&gt;% # Initiate the graph, with Age on the x-axis and determining the bar color and Risk on the y-axis ggplot(aes(x = Age, y = Risk, fill = Age)) + # Make a column (bar) graph and add a black outline to the bars geom_col(color = &quot;black&quot;) + # Add percent labels geom_label( aes(label = paste0(Risk, &quot;%&quot;)), # Add percent to the end of the numeric value vjust = -0.5 # Center the label ) + # Change the y-axis label ylab(&quot;Percent receiving early prenatal care&quot;) + # Change the y-axis scale limits ylim(0, 100) + # Set the color scheme (use RColorBrewer color set 3) scale_fill_brewer(palette = &quot;Set3&quot;) + # Set the overall ggplot theme theme_minimal() + # Set the plot title ggtitle(&quot;Prenatal Care in First Trimester by Age Group, 2022&quot;) + # Set specific theme elements theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1), # Tilt the x-axis labels plot.title = element_text(hjust = 0.5)) + # Center the plot title # Remove the legend guides(fill = &quot;none&quot;) See the code comments explaining this code above for details. The following three graphs are similar, so there are no code comments included with them. 2.6.2 Prenatal care initiation by maternal education read_csv(&quot;Tables/edu.csv&quot;, show_col_types = FALSE) %&gt;% mutate(Risk = round(Risk * 100, 1)) %&gt;% mutate(Education = factor( .$Education, levels = c(&quot;Less than High School&quot;, &quot;High School Graduate or GED&quot;, &quot;Some College&quot;, &quot;Bachelors Degree&quot;, &quot;Masters or PhD&quot;, &quot;Unknown&quot;) )) %&gt;% ggplot(aes(x = Education, y = Risk, fill = Education)) + geom_col(color = &quot;black&quot;) + geom_label( aes(label = paste0(Risk, &quot;%&quot;)), vjust = -0.5 ) + ylab(&quot;Percent receiving early prenatal care&quot;) + ylim(0, 100) + scale_fill_brewer(palette = &quot;Set3&quot;) + theme_minimal() + ggtitle(&quot;Prenatal Care in First Trimester by Education Level, 2022&quot;) + theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1), plot.title = element_text(hjust = 0.5)) + guides(fill = &quot;none&quot;) Note one addition here: the Education variable is created as a factor, which allows the x-axis to be ordered logically. If the education variable were a character vector instead of a factor, the education levels would be alphabetized. 2.6.3 Prenatal care initiation by marital status read_csv(&quot;Tables/marital.csv&quot;, show_col_types = FALSE) %&gt;% mutate(Risk = round(Risk * 100, 1)) %&gt;% mutate(`Marital Status` = factor(.$`Marital Status`, levels = c(&quot;Married&quot;, &quot;Unmarried&quot;, &quot;Not Stated&quot;))) %&gt;% ggplot(aes(x = `Marital Status`, y = Risk, fill = `Marital Status`)) + geom_col(color = &quot;black&quot;) + geom_label( aes(label = paste0(Risk, &quot;%&quot;)), vjust = -0.5 ) + ylab(&quot;Percent receiving early prenatal care&quot;) + ylim(0, 100) + scale_fill_brewer(palette = &quot;Set3&quot;) + theme_minimal() + ggtitle(&quot;Prenatal Care in First Trimester by Marital Status, 2022&quot;) + theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1), plot.title = element_text(hjust = 0.5)) + guides(fill = &quot;none&quot;) As with education status, marital status is changed to a factor so the x-axis is properly ordered. 2.6.4 Prenatal care initiation by race and ethnicity read_csv(&quot;Tables/race.csv&quot;, show_col_types = FALSE) %&gt;% mutate(Risk = round(Risk * 100, 1)) %&gt;% mutate(`Race/Ethnicity` = factor( .$`Race/Ethnicity`, levels = c(&quot;White/Non-Hispanic&quot;, &quot;Other/Non-Hispanic&quot;, &quot;African American/Non-Hispanic&quot;, &quot;Hispanic&quot;) )) %&gt;% ggplot(aes(x = `Race/Ethnicity`, y = Risk, fill = `Race/Ethnicity`)) + geom_col(color = &quot;black&quot;) + geom_label( aes(label = paste0(Risk, &quot;%&quot;)), vjust = -0.5 ) + ylab(&quot;Percent receiving early prenatal care&quot;) + ylim(0, 100) + scale_fill_brewer(palette = &quot;Set3&quot;) + theme_minimal() + ggtitle(&quot;Prenatal Care in First Trimester by Race/Ethnicity, 2022&quot;) + theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1), plot.title = element_text(hjust = 0.5)) + guides(fill = &quot;none&quot;) Once again, race/ethnicity is changed to a factor to preserve a logical x-axis: in this case, the order was chosen to show groups from highest early prenatal care uptake to lowest. 2.6.5 Birthweight by prenatal care initiation For the final graph, we create a stacked bar graph. This is more useful in this case, because we can more easily show the effect of prenatal care initiation on birthweight. # Read the birthweight.csv dataset read_csv(&quot;Tables/birthweight.csv&quot;, show_col_types = FALSE) %&gt;% # Multiply the risks by 100 (to create percents) and round to the tenths place. mutate(Values = round(Values * 100, 1)) %&gt;% # Change the birthweight variable to an ordered factor mutate(`Birth weight (g)` = factor( .$`Birth weight (g)`, levels = c(&quot;&lt;1500&quot;, &quot;1500-2499&quot;, &quot;&gt;=2500&quot;, &quot;Unknown&quot;) )) %&gt;% # Initiate the graph, with birthweight on the x-axis and percent on the y-axis ggplot(aes(x = `Birth weight (g)`, y = Values, fill = `Prenatal Care`)) + # Create a column (bar) graph geom_col(color = &quot;black&quot;) + # Add percent labels geom_label( aes(label = paste0(Values, &quot;%&quot;)), # Add percent to the end of the numeric value position = position_stack(vjust = 0.5), # Center the labels and stack them like the bars show.legend = FALSE # Remove the labels from the legend ) + # Set the y-axis label ylab(&quot;Percent&quot;) + # Set the y-axis limits ylim(0, 100) + # Set the color scheme (to RColorBrewer&#39;s color set 3) scale_fill_brewer(palette = &quot;Set3&quot;) + # Set the ggplot theme theme_minimal() + # Set the plot title ggtitle(&quot;Prenatal Care in First Trimester by Birth Weight, 2022&quot;) + # Change theme settings theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1), # Angle the x-axis labels plot.title = element_text(hjust = 0.5), # Center the plot title legend.position = &quot;right&quot;) # Position the legend See the code comments explaining this code above for details. 2.7 Calculating risk ratios for early prenatal care In this section, we generate tables that show risk ratios for each category graphed above. The ratios calculated here say how many times as likely a member of each group was to obtain early prenatal care (initiated in the first trimester) compared to the group overall. First, we need to load some additional libraries: suppressPackageStartupMessages(library(knitr)) suppressPackageStartupMessages(library(kableExtra)) knitr is used to “knit” (render) RMarkdown files. In addition to bar-graphs.Rmd, this presentation was generated with knitr. kableExtra is used to style tables generated with kable(), which is a function from knitr. The tables in the sections above were kables styled with kableExtra. 2.7.1 Risk of prenatal care initiation by maternal age We need to calculate a risk ratio here. As a reminder, risk ratios are calculated as \\(\\frac{a/(a+b)}{c/(c+d)}\\), where: \\(a\\) are those with the outcome who were exposed. \\(b\\) are those without the outcome who were exposed. \\(c\\) are those with the outcome who were not exposed. \\(d\\) are those without the outcome who were not exposed. In this case, we will calculate the risk of each category over the overall population’s risk for the risk ratio. The following code demonstrates how this is done: # Read the age.csv dataset read_csv(&quot;Tables/age.csv&quot;, show_col_types = FALSE) %&gt;% # Remove the existing Risk column select(!Risk) %&gt;% # Generate a totals row which sums all births with early care, no early care, and not stated bind_rows( summarise_all(., ~if(is.numeric(.)) sum(.) else &quot;Total&quot;) ) %&gt;% # Calculate risk again mutate( &quot;Risk&quot; = Early / Total ) %&gt;% # Calculate a risk ratio by dividing each row&#39;s risk by the risk in the Total row mutate( &quot;RR&quot; = Risk / filter(., Age == &quot;Total&quot;) %&gt;% pull(Risk) ) %&gt;% # Select only the needed columns select(Age, Total, RR) %&gt;% # Generate a table kable(&quot;html&quot;) %&gt;% kable_material(&quot;striped&quot;) Age Total RR 19 and under 308 0.6352893 20 through 24 1387 0.7896204 25 through 29 3085 0.9505086 30 through 34 4981 1.0753748 35 through 39 2786 1.0593476 40 through 44 595 1.0276739 45 or older 47 1.0118822 Not Stated 1 0.0000000 Total 13190 1.0000000 Note: the code used to generate the tables is different in this presentation for design consistency. You can refer to bar-graphs.Rmd for the style commands used there. The next three tables are generated the same way, so code comments are not given. 2.7.2 Risk of prenatal care initiation by maternal education read_csv(&quot;Tables/edu.csv&quot;, show_col_types = FALSE) %&gt;% select(!Risk) %&gt;% bind_rows( summarise_all(., ~if(is.numeric(.)) sum(.) else &quot;Total&quot;) ) %&gt;% mutate( &quot;Risk&quot; = Early / Total ) %&gt;% mutate( &quot;RR&quot; = Risk / filter(., Education == &quot;Total&quot;) %&gt;% pull(Risk) ) %&gt;% select(Education, Total, RR) %&gt;% kable(&quot;html&quot;) %&gt;% kable_material(&quot;striped&quot;) Education Total RR Less than High School 1131 0.6992301 High School Graduate or GED 1732 0.7994403 Some College 2637 0.9182424 Bachelors Degree 4392 1.1079030 Masters or PhD 3216 1.1424848 Unknown 82 0.6462648 Total 13190 1.0000000 2.7.3 Risk of prenatal care initiation by marital status read_csv(&quot;Tables/marital.csv&quot;, show_col_types = FALSE) %&gt;% select(!Risk) %&gt;% bind_rows( summarise_all(., ~if(is.numeric(.)) sum(.) else &quot;Total&quot;) ) %&gt;% mutate( &quot;Risk&quot; = Early / Total ) %&gt;% mutate( &quot;RR&quot; = Risk / filter(., `Marital Status` == &quot;Total&quot;) %&gt;% pull(Risk) ) %&gt;% select(`Marital Status`, Total, RR) %&gt;% kable(&quot;html&quot;) %&gt;% kable_material(&quot;striped&quot;) Marital Status Total RR Married 9458 1.0806717 Unmarried 3728 0.7964074 Not Stated 4 0.0000000 Total 13190 1.0000000 2.7.4 Risk of prenatal care initiation by race and ethnicity read_csv(&quot;Tables/race.csv&quot;, show_col_types = FALSE) %&gt;% select(!Risk) %&gt;% bind_rows( summarise_all(., ~if(is.numeric(.)) sum(.) else &quot;Total&quot;) ) %&gt;% mutate( &quot;Risk&quot; = Early / Total ) %&gt;% mutate( &quot;RR&quot; = Risk / filter(., `Race/Ethnicity` == &quot;Total&quot;) %&gt;% pull(Risk) ) %&gt;% select(`Race/Ethnicity`, Total, RR) %&gt;% kable(&quot;html&quot;) %&gt;% kable_material(&quot;striped&quot;) Race/Ethnicity Total RR White/Non-Hispanic 6478 1.1219963 African American/Non-Hispanic 2620 0.8474431 Other/Non-Hispanic 1704 0.9999717 Hispanic 2388 0.8364554 Total 13190 1.0000000 2.8 Final notes This is the end of the R code contributed to the 2024 Maternal and Child Health Report. Not all of these graphics and tables will be included in the final report, but with R, it is relatively painless to generate more graphs and tables than are needed. The North Carolina BabyBook is published by the NC Department of Health and Human Services (DHHS) State Center for Health Statistics, and can be found online.↩︎ "],["stis.html", "Section 3 STIs 3.1 Libraries 3.2 Importing chlamydia data 3.3 Filtering data to exclude non-Wake cases 3.4 Loading census data 3.5 Tally cases by group and calculate incidence 3.6 Graphing chlamydia 3.7 Tallying and graphing gonorrhea 3.8 Final notes", " Section 3 STIs As a local health department, WCHHS has access to the North Carolina Electronic Disease Surveillance System (NC EDSS), which is a database that includes every case of a reportable condition in North Carolina. NC EDSS can generate a line list of every case of a reportable disease. For this section of the presentation, I’ve generated new graphics from line list data for chlamydia and gonorrhea, which are two of the top ten reportable conditions in Wake County and part of a concerning trend of increasing STI cases nationwide. The graphics display incidence proportions of chlamydia and gonorrhea over the last five years, stratified by age group, race, and municipality. Before the code for the graphs, I will walk through the process of filtering data to systematically exclude non-Wake cases and creating a City_guess variable to guess the municipality in case of typos. The data used for these reports is confidential and cannot be exported, so this portion of the presentation cannot be regenerated outside WCHHS systems. However, if you have access to the WCHHS Epidemiology SharePoint site, you can tweak and regenerate these graphs. 3.1 Libraries suppressPackageStartupMessages(library(ezepi)) suppressPackageStartupMessages(library(stringdist)) There are three non-standard libraries used in this script. ezepi, which I wrote outside of the practicum, is loaded here to use some specific functions I wrote for cleanliness. If you would like to use it, you can find installation instructions on its GitHub page. tidyverse, which is loaded here by the ezepi call. stringdist, short for string distance, which gives methods to evaluate how “distant” a string (a character value) is from another string. 3.2 Importing chlamydia data Now, we import the data. The data are stored in ten separate .csv files: one for each year and disease. These files are slightly modified from the NC EDSS line list outputs to remove a few lines of unnecessary headers and the footnote at the bottom. First, we define the list of tables and write a function to import them all at once. # List tables to import tables &lt;- list(&quot;chla19&quot;, &quot;chla20&quot;, &quot;chla21&quot;, &quot;chla22&quot;, &quot;chla23&quot;) # Create a reader function sesh_read &lt;- function(x){ read_csv( paste0(&quot;../Data/&quot;, x, &quot;.csv&quot;), # Specify the file path show_col_types = FALSE, # Prevent unnecessary output col_types = &quot;ncccccccncccccccccncccccccccccccccccncc&quot; # Define column types in data ) } With in read_csv(), we’re performing two notable tasks: Using paste0() to add the folder (go up one folder, then into Data) and file extension (.csv) to the file name (x). Defining the column types. We define a few as numeric, such as the Event ID and the patient age, but we set most to character, including dates and ZIP codes. We’ll fix dates in another step. Next, we use this function to import the data, then combine the five Chlamydia tables and fix some variables. # Apply the sesh_read function to the list of tables (importing five tables) chla &lt;- lapply( tables, sesh_read ) %&gt;% # Combine the five tables into one bind_rows() %&gt;% # Alter some variables mutate( &quot;Create Date&quot; = mdy(`Create Date`), # `mdy` tells R this is a date in month-day-year format &quot;Birthdate&quot; = mdy(`Birthdate`), &quot;City&quot; = toupper(City), # `toupper` changes the cities to all uppercase &quot;Symptom Onset Date&quot; = mdy(`Symptom Onset Date`), &quot;Reporting Date to CDC&quot; = mdy(`Reporting Date to CDC`), &quot;Diagnosis Date&quot; = mdy(`Diagnosis Date`), &quot;Date Initial Report to PH&quot; = mdy(`Date Initial Report to PH`), &quot;Date Identified as Contact&quot; = mdy(`Date Identified as Contact`), &quot;Specimen Date&quot; = mdy(`Specimen Date`), &quot;MMWR Date&quot; = mdy(`MMWR Date`), &quot;Zip&quot; = str_sub(Zip, 1, 5) # `str_sub` cuts ZIP codes down to just the first five digits ) %&gt;% # Change the name of the Zip variable to ZIP rename(ZIP = Zip) Notice the use of the pipe (%&gt;%) here: we perform several functions on the imported data and assign (with &lt;-) the final product of our full expression to chla in the first row. See the code comments for explanations of what individual lines are doing. 3.3 Filtering data to exclude non-Wake cases WCHHS, as a very large metropolitan health department, frequently provides STI testing to clients who live outside Wake County. All test results performed in Wake, regardless of the patient’s county of residence, are reported to Wake County through NC EDSS. To analyze trends in Wake alone, we need to systematically filter out non-Wake cases. In this script, to filter out non-Wake cases, I used three fields: reported county, ZIP, and city. Cases needed to have a match in at least one of these three fields to be included. For County, only Wake County (or NA) was accepted. For City and ZIP, this code was used: # Pull the list of accepted ZIP codes from wake_zips.csv zips &lt;- read_csv(&quot;wake_zips.csv&quot;, show_col_types = FALSE, col_types = &quot;c&quot;) # Set the list of accepted cities cities &lt;- c(&quot;Apex&quot;, &quot;Cary&quot;, &quot;Fuquay&quot;, &quot;Fuquay-Varina&quot;, &quot;Garner&quot;, &quot;Holly Springs&quot;, &quot;Knightdale&quot;, &quot;Morrisville&quot;, &quot;Raleigh&quot;, &quot;Rolesville&quot;, &quot;Wake Forest&quot;, &quot;Wendell&quot;, &quot;Zebulon&quot;, &quot;Durham&quot;, &quot;Angier&quot;) %&gt;% # Convert the list to uppercase (to match the City field in the data) toupper() Next, we write the function to filter the data. chla_filtered &lt;- chla %&gt;% mutate( # Create the &quot;del&quot; (delete) variable to mark cases for deletion &quot;del&quot; = case_when( # If county is not Wake or NA, mark for deletion !is.na(County) &amp; County != &quot;Wake County&quot; ~ TRUE, # If ZIP is not a Wake ZIP or NA and the county is not given, mark for deletion !is.na(ZIP) &amp; !(ZIP %in% zips$ZIP) &amp; is.na(County) ~ TRUE, # If city is not a Wake municipality or NA and the county is not given, mark for deletion !is.na(City) &amp; !( stringdistmatrix(chla$City, cities, method = &quot;lv&quot;) %&gt;% apply(1, function(row){any(row &lt;= 5)}) ) &amp; is.na(County) ~ TRUE, # If county, ZIP, and city are all NA, mark for deletion is.na(County) &amp; is.na(ZIP) &amp; is.na(City) ~ TRUE, # Otherwise, mark to keep .default = FALSE ), # Create a variable that guesses (fixes typos in) the city column &quot;City_guess&quot; = map_chr(City, function(city){ # If the city is in Wake and spelled correctly, keep it as is if(city %in% cities){ return(city) # If there is no city given, don&#39;t guess (say NA) } else if(is.na(city)){ return(NA_character_) # Otherwise, compare to Wake cities and pick the best match } else { distances &lt;- stringdist(city, cities, method = &quot;lv&quot;) best_match &lt;- cities[which.min(distances)] return(best_match) } }) ) %&gt;% mutate( # Make manual edits to the city guess &quot;City_guess&quot; = case_when( # If the city isn&#39;t given in the data, set the guess to &quot;OTHER&quot; is.na(City) ~ &quot;OTHER&quot;, # If the city guess was Fuquay (common shorthand), use the full name City_guess == &quot;FUQUAY&quot; ~ &quot;FUQUAY-VARINA&quot;, # If the city was Wake, set the guess to &quot;OTHER&quot; City == &quot;WAKE&quot; ~ &quot;OTHER&quot;, # If the city was RaleighRaleigh (common typo), set the guess to &quot;RALEIGH&quot; City == &quot;RALEIGHRALEIGH&quot; ~ &quot;RALEIGH&quot;, # If the guess is too different from the original, set the guess to &quot;OTHER&quot; stringdist(City, City_guess, method = &quot;lv&quot;) &gt; 3 ~ &quot;OTHER&quot;, # If none of the above apply, do not alter the guess .default = City_guess ) ) %&gt;% # Move the guess variable next to the city variable in the data (for convenience) relocate(City_guess, .after = City) %&gt;% # Filter cases, keeping only those NOT marked for deletion filter(del == FALSE) %&gt;% # Remove the deletion marker variable select(!del) See the comments in the above code for a complete description of its function. Some key notes about the use of stringdist to guess and match cities: stringdist has multiple algorithm options. For this task, I used Levenshtein distance (lv), which simply counts the number of deletions, insertions, and substitutions needed to convert one string to another. When marking cases for deletion, I chose to set the maximum distance between the city and the nearest guess to 5. This was chosen through trial and error with the data and is arbitrary; use whatever cutoff works best on the data you’re working with. When guessing the closest city, however, I chose a cutoff of 3. Again, this was based on trial and error. A more specific cutoff for the city guess is sensible because it only impacts how data is classified, not whether it is included. Additionally, because it is somewhat hard to parse, here is the logic (in words) for how cases are selected for deletion: IF… the county is defined but is not Wake, THEN delete (set del to TRUE). the ZIP is defined but is not in wake_zips AND the county is undefined, THEN delete. the city is defined but is not within 5 substitutions, insertions, and deletions of any municipality in cities AND the county is undefined, THEN delete. the county, ZIP code, and city are all undefined, THEN delete. ELSE keep the case (set del to FALSE). 3.4 Loading census data Next, we need to load census data for age and race/ethnicity to calculate incidence. The included census_18-22.csv spreadsheet is a combination of ACS2 and Census3 demographic data from 2018-2022. Data has been manually combined and calculated (where possible) so that the differing fields between the ACS and Census are comparable. 3.4.1 Loading age data # Read in the spreadsheet and set all column types to character census_age &lt;- read_csv(&quot;census_18-22.csv&quot;, col_types = &quot;cccccc&quot;, show_col_types = FALSE) %&gt;% # Select only the rows with age data slice(., 6:28, 30:35, 43) %&gt;% # Remove the comma separators from numbers and set them to numeric mutate( &quot;2018&quot; = as.numeric(str_remove_all(`2018`, &quot;,&quot;)), &quot;2019&quot; = as.numeric(str_remove_all(`2019`, &quot;,&quot;)), &quot;2020&quot; = as.numeric(str_remove_all(`2020`, &quot;,&quot;)), &quot;2021&quot; = as.numeric(str_remove_all(`2021`, &quot;,&quot;)), &quot;2022&quot; = as.numeric(str_remove_all(`2022`, &quot;,&quot;)) ) %&gt;% # Define and calculate population totals for custom age groups mutate_rows( &quot;5 to 17 years&quot; = `Total population` - `18 years and over`, &quot;18 to 24 years&quot; = `Under 5 years` + `5 to 9 years` + `10 to 14 years` + `15 to 19 years` + `20 to 24 years` - `Under 18 years`, &quot;25 to 44 years&quot; = `25 to 34 years` + `35 to 44 years`, &quot;45 to 64 years&quot; = `45 to 54 years` + `55 to 59 years` + `60 to 64 years` ) %&gt;% # Add a column for 2023 with the same population as 2022 mutate(&quot;2023&quot; = `2022`) %&gt;% # Pivot the dataset to merge later pivot_longer( cols = -Label, names_to = &quot;Year&quot;, names_transform = as.numeric, values_to = &quot;Population&quot; ) See the comments in the code for specific steps. One note: mutate_rows(), though it looks like a tidyverse function, is actually an ezepi function. Make sure to load ezepi if you want to use it in other scripts. 3.4.2 Loading race and ethnicity data census_raceth &lt;- read_csv(&quot;census_18-22.csv&quot;, col_types = &quot;cccccc&quot;, show_col_types = FALSE) %&gt;% slice(., 43:48, 53, 61, 66, 80) %&gt;% mutate( &quot;2018&quot; = as.numeric(str_remove_all(`2018`, &quot;,&quot;)), &quot;2019&quot; = as.numeric(str_remove_all(`2019`, &quot;,&quot;)), &quot;2020&quot; = as.numeric(str_remove_all(`2020`, &quot;,&quot;)), &quot;2021&quot; = as.numeric(str_remove_all(`2021`, &quot;,&quot;)), &quot;2022&quot; = as.numeric(str_remove_all(`2022`, &quot;,&quot;)) ) %&gt;% mutate(&quot;2023&quot; = `2022`) %&gt;% pivot_longer( cols = -Label, names_to = &quot;Year&quot;, names_transform = as.numeric, values_to = &quot;Population&quot; ) This section is similar to the above section, so comments are not included. 3.5 Tally cases by group and calculate incidence Now, we need to group and count the line list data by age, race, and municipality. We will calculate incidence for age and race and display counts for municipality. 3.5.1 Chlamydia incidence by age group First, we’ll do this by age group. # Start with the filtered data chla_age &lt;- chla_filtered %&gt;% # Create some variables mutate( # Variable for census age groups (5/10 year groups) census_age = factor( # Use `case_when()` (see note) to determine the values x = case_when( Age &lt; 5 ~ &quot;Under 5 years&quot;, Age &gt;= 5 &amp; Age &lt;= 9 ~ &quot;5 to 9 years&quot;, Age &gt;= 10 &amp; Age &lt;= 14 ~ &quot;10 to 14 years&quot;, Age &gt;= 15 &amp; Age &lt;= 19 ~ &quot;15 to 19 years&quot;, Age &gt;= 20 &amp; Age &lt;= 24 ~ &quot;20 to 24 years&quot;, Age &gt;= 25 &amp; Age &lt;= 34 ~ &quot;25 to 34 years&quot;, Age &gt;= 35 &amp; Age &lt;= 44 ~ &quot;35 to 44 years&quot;, Age &gt;= 45 &amp; Age &lt;= 54 ~ &quot;45 to 54 years&quot;, Age &gt;= 55 &amp; Age &lt;= 59 ~ &quot;55 to 59 years&quot;, Age &gt;= 60 &amp; Age &lt;= 64 ~ &quot;60 to 64 years&quot;, Age &gt;= 65 &amp; Age &lt;= 74 ~ &quot;65 to 74 years&quot;, Age &gt;= 75 &amp; Age &lt;= 84 ~ &quot;75 to 84 years&quot;, Age &gt;= 85 ~ &quot;85 years and over&quot; ), # Set the factor&#39;s levels (to order them) levels = c(&quot;Under 5 years&quot;, &quot;5 to 9 years&quot;, &quot;10 to 14 years&quot;, &quot;15 to 19 years&quot;, &quot;20 to 24 years&quot;, &quot;25 to 34 years&quot;, &quot;35 to 44 years&quot;, &quot;45 to 54 years&quot;, &quot;55 to 59 years&quot;, &quot;60 to 64 years&quot;, &quot;65 to 74 years&quot;, &quot;75 to 84 years&quot;) ), # Variable for six age groups (more standard) age_6 = case_when( Age &lt; 5 ~ &quot;Under 5 years&quot;, Age &gt;= 5 &amp; Age &lt; 18 ~ &quot;5 to 17 years&quot;, Age &gt;= 18 &amp; Age &lt; 25 ~ &quot;18 to 24 years&quot;, Age &gt;= 25 &amp; Age &lt; 45 ~ &quot;25 to 44 years&quot;, Age &gt;= 45 &amp; Age &lt; 65 ~ &quot;45 to 64 years&quot;, Age &gt;= 65 ~ &quot;65 years and over&quot; ), # Variable for the year when the case occurred Year = year(`MMWR Date`) ) %&gt;% # Group by case year and age group group_by(Year, age_6) %&gt;% # Tally (count) the cases in each group tally(name = &quot;Count&quot;) %&gt;% # Fill in any year/age combos with no cases complete(fill = list(Count = 0)) %&gt;% # Filter out groups with no age filter(!is.na(age_6)) %&gt;% # Join (merge) the tallied data with the population totals left_join( census_age, by = join_by(age_6 == Label, Year) ) %&gt;% # Calculate the incidence for each year/age group mutate(&quot;Incidence&quot; = Count / Population * 100000, # Change the age group variable to a factor (for ordering) &quot;age_6&quot; = factor( x = age_6, levels = c(&quot;Under 5 years&quot;, &quot;5 to 17 years&quot;, &quot;18 to 24 years&quot;, &quot;25 to 44 years&quot;, &quot;45 to 64 years&quot;, &quot;65 years and over&quot;) )) See the code comments for complete details, but to summarize, this block does the following: Mutate (create) age grouping variables and a year variable based on existing variables. Group by year and age group. Tally (count) the cases in each group. Fill in any missing groups with zeroes and filter out undefined age groups. Join (merge) the tallied data and the population data Calculate incidence and order the age grouping variable case_when() is a very useful function from the tidyverse that makes if/else statements more compact. Each line in this example is an if/then statement, and each comma means “else”. The function also includes an option, .default, that is the final “else” with no “if”. For more information, see the dplyr help page or type ?case_when with tidyverse loaded. 3.5.2 Chlamydia incidence by race Next, we’ll do it by race. chla_race &lt;- chla_filtered %&gt;% mutate( &quot;race_5&quot; = case_when( Race == &quot;White&quot; ~ &quot;White&quot;, Race == &quot;Black or African American&quot; ~ &quot;Black or African American&quot;, Race == &quot;Asian&quot; ~ &quot;Asian&quot;, str_detect(Race, &quot;,&quot;) ~ &quot;Two or more races&quot;, Race == &quot;Unknown&quot; | is.na(Race) ~ NA, .default = &quot;Some other race&quot; ), Year = year(`MMWR Date`) ) %&gt;% group_by(Year, race_5) %&gt;% tally(name = &quot;Count&quot;) %&gt;% complete(fill = list(Count = 0)) %&gt;% filter(!is.na(race_5)) %&gt;% left_join( census_raceth, by = join_by(race_5 == Label, Year) ) %&gt;% mutate(&quot;Incidence&quot; = Count / Population * 100000, &quot;race_5&quot; = factor( x = race_5, levels = c(&quot;Asian&quot;, &quot;Black or African American&quot;, &quot;White&quot;, &quot;Some other race&quot;, &quot;Two or more races&quot;) )) This code block is similar, so code comments are not included. 3.5.3 Chlamydia count by municipality Last, we’ll calculate counts by municipality in Wake County. Incidence is not calculated here because of the difficulty of determining whether a case lives within city limits. # Start with the filtered data chla_city &lt;- chla_filtered %&gt;% # Create a variable for the year when the case occurred mutate(Year = year(`MMWR Date`)) %&gt;% # Group by year and city (determined algorithmically) group_by(Year, City_guess) %&gt;% # Tally (count) the cases in each group tally(name = &quot;Count&quot;) %&gt;% # Fill in any year/age combos with no cases complete(fill = list(Count = 0)) %&gt;% # Filter out groups with no city filter(!is.na(City_guess)) %&gt;% # Suppress year/city values with 5 or fewer cases mutate( &quot;Count&quot; = case_when( Count &lt;= 5 ~ NA, .default = Count ) ) See the code comments for details. Some notable changes from the prior versions: Municipalities do not need to be combined into groups, so there is no mutate for that. Because some municipalities (or the portion of them inside Wake) are small, counts of 5 or fewer are suppressed to protect anonymity. 3.6 Graphing chlamydia Finally, we create the graphics. These are best represented as bar graphs, though line graphs with multiple lines may also be appropriate. 3.6.1 Chlamydia incidence by age group Since the data is already prepared for us, we just need to code the graph. We do this using ggplot2, part of the tidyverse package. # Set up the plot, specifying dataset and variables ggplot( chla_age, aes(x = age_6, y = Incidence, fill = as.character(Year)) ) + # Use a bar (column) graph with multiple bars for each age group geom_col(position = position_dodge()) + # Set the color scheme (using RColorBrewer) scale_fill_brewer(palette = &quot;Set2&quot;) + # Set the axis and legend labels labs( x = &quot;Age group&quot;, y = &quot;Cases per 100k population&quot;, fill = &quot;Year&quot; ) + # Set the ggplot theme theme_minimal() + # Set the plot title ggtitle(&quot;Chlamydia Incidence by Age Group in Wake County, 2019-2023&quot;) + # Center the plot title and put the legend on the bottom theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot; ) This bar graph shows the incidence (sometimes called rate) of chlamydia in each age group over the prior five years. If you’d like, you can open this RMarkdown file (03-STI.Rmd) on the SharePoint and play with the graph code to edit the settings. 3.6.2 Chlamydia incidence by race Now we graph by race: ggplot( chla_race, aes(x = race_5, y = Incidence, fill = as.character(Year)) ) + geom_col(position = position_dodge()) + scale_fill_brewer(palette = &quot;Set2&quot;) + labs( x = &quot;Race&quot;, y = &quot;Cases per 100k population&quot;, fill = &quot;Year&quot; ) + theme_minimal() + ggtitle(&quot;Chlamydia Incidence by Race in Wake County, 2019-2023&quot;) + theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot; ) This is practically the same as the age graph, so the code should be familiar. 3.6.3 Chlamydia count by municipality Finally, we’ll make a counts graph for municipalities. This would look really ugly if it were the same orientation, so let’s graph it sideways! # Set up the graph ggplot( # Specify the dataset chla_city, aes( x = Count, # Count on the x-axis y = fct_rev(City_guess), # Reversed city on y (to alphabetize) fill = fct_rev(as.factor(Year)) # Reversed year (to order top to bottom) ) ) + # Use a bar (column) graph with multiple bars for each age group geom_col(position = position_dodge()) + # Set the axis and legend labels labs( x = &quot;Cases&quot;, y = &quot;Municipality&quot;, fill = &quot;Year&quot; ) + # Set the color scheme (using RColorBrewer) and flip the legend scale_fill_brewer(palette = &quot;Set2&quot;, guide = guide_legend(reverse = TRUE)) + # Set the ggplot theme theme_minimal() + # Set the plot title ggtitle(&quot;Chlamydia Count by Municipality in Wake County, 2019-2023&quot;) + # Center the plot title and put the legend on the bottom theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot; ) This graph shows the counts of chlamydia each year for each Wake County municipality. Of course, because of population, Raleigh overtakes the graph. We can also filter Raleigh out using this code: ggplot( chla_city %&gt;% filter(City_guess != &quot;RALEIGH&quot;), # Pipe the data into a filter aes( x = Count, y = fct_rev(City_guess), fill = fct_rev(as.factor(Year)) ) ) + geom_col(position = position_dodge()) + labs( x = &quot;Cases&quot;, y = &quot;Municipality&quot;, fill = &quot;Year&quot; ) + scale_fill_brewer(palette = &quot;Set2&quot;, guide = guide_legend(reverse = TRUE)) + theme_minimal() + ggtitle(&quot;Chlamydia Count by Municipality in Wake County, 2019-2023&quot;) + theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot; ) Now, we can see a bit more detail for the other municipalities’ counts. 3.7 Tallying and graphing gonorrhea Of course, there are two diseases we’d like to analyze here. Next, we’ll analyze gonorrhea. Since this code is practically the same as for chlamydia, I’ll avoid explanations and just include the code. 3.7.1 Importing # Import data tables &lt;- list(&quot;gono19&quot;, &quot;gono20&quot;, &quot;gono21&quot;, &quot;gono22&quot;, &quot;gono23&quot;) sesh_read &lt;- function(x){ read_csv( paste0(&quot;../Data/&quot;, x, &quot;.csv&quot;), show_col_types = FALSE, col_types = &quot;ncccccccncccccccccncccccccccccccccccncc&quot; ) } gono &lt;- lapply( tables, sesh_read ) %&gt;% bind_rows() %&gt;% mutate( &quot;Create Date&quot; = mdy(`Create Date`), &quot;Birthdate&quot; = mdy(`Birthdate`), &quot;City&quot; = toupper(City), &quot;Symptom Onset Date&quot; = mdy(`Symptom Onset Date`), &quot;Reporting Date to CDC&quot; = mdy(`Reporting Date to CDC`), &quot;Diagnosis Date&quot; = mdy(`Diagnosis Date`), &quot;Date Initial Report to PH&quot; = mdy(`Date Initial Report to PH`), &quot;Date Identified as Contact&quot; = mdy(`Date Identified as Contact`), &quot;Specimen Date&quot; = mdy(`Specimen Date`), &quot;MMWR Date&quot; = mdy(`MMWR Date`), &quot;Zip&quot; = str_sub(Zip, 1, 5) ) %&gt;% rename(ZIP = Zip) 3.7.2 Filtering # Filter out non-Wake cases zips &lt;- read_csv(&quot;wake_zips.csv&quot;, show_col_types = FALSE, col_types = &quot;c&quot;) cities &lt;- c(&quot;Apex&quot;, &quot;Cary&quot;, &quot;Fuquay-Varina&quot;, &quot;Fuquay&quot;, &quot;Garner&quot;, &quot;Holly Springs&quot;, &quot;Knightdale&quot;, &quot;Morrisville&quot;, &quot;Raleigh&quot;, &quot;Rolesville&quot;, &quot;Wake Forest&quot;, &quot;Wendell&quot;, &quot;Zebulon&quot;, &quot;Durham&quot;, &quot;Angier&quot;) %&gt;% toupper() gono_filtered &lt;- gono %&gt;% mutate( &quot;del&quot; = case_when( !is.na(County) &amp; County != &quot;Wake County&quot; ~ TRUE, !is.na(ZIP) &amp; !(ZIP %in% zips$ZIP) &amp; is.na(County) ~ TRUE, !is.na(City) &amp; !( stringdistmatrix(gono$City, cities, method = &quot;lv&quot;) %&gt;% apply(1, function(row){any(row &lt;= 5)}) ) &amp; is.na(County) ~ TRUE, is.na(County) &amp; is.na(ZIP) &amp; is.na(City) ~ TRUE, .default = FALSE ), &quot;City_guess&quot; = map_chr(City, function(city){ if(city %in% cities){ return(city) } else if(is.na(city)){ return(NA_character_) } else { distances &lt;- stringdist(city, cities, method = &quot;lv&quot;) best_match &lt;- cities[which.min(distances)] return(best_match) } }) ) %&gt;% mutate( &quot;City_guess&quot; = case_when( is.na(City) ~ &quot;OTHER&quot;, City_guess == &quot;FUQUAY&quot; ~ &quot;FUQUAY-VARINA&quot;, City == &quot;WAKE&quot; ~ &quot;OTHER&quot;, City == &quot;RALEIGHRALEIGH&quot; ~ &quot;RALEIGH&quot;, stringdist(City, City_guess, method = &quot;lv&quot;) &gt; 3 ~ &quot;OTHER&quot;, .default = City_guess ) ) %&gt;% relocate(City_guess, .after = City) %&gt;% filter(del == FALSE) %&gt;% select(!del) 3.7.3 Tallying # Tally Wake cases by age, race, and city, then calculate incidence gono_age &lt;- gono_filtered %&gt;% mutate( census_age = factor( x = case_when( Age &lt; 5 ~ &quot;Under 5 years&quot;, Age &gt;= 5 &amp; Age &lt;= 9 ~ &quot;5 to 9 years&quot;, Age &gt;= 10 &amp; Age &lt;= 14 ~ &quot;10 to 14 years&quot;, Age &gt;= 15 &amp; Age &lt;= 19 ~ &quot;15 to 19 years&quot;, Age &gt;= 20 &amp; Age &lt;= 24 ~ &quot;20 to 24 years&quot;, Age &gt;= 25 &amp; Age &lt;= 34 ~ &quot;25 to 34 years&quot;, Age &gt;= 35 &amp; Age &lt;= 44 ~ &quot;35 to 44 years&quot;, Age &gt;= 45 &amp; Age &lt;= 54 ~ &quot;45 to 54 years&quot;, Age &gt;= 55 &amp; Age &lt;= 59 ~ &quot;55 to 59 years&quot;, Age &gt;= 60 &amp; Age &lt;= 64 ~ &quot;60 to 64 years&quot;, Age &gt;= 65 &amp; Age &lt;= 74 ~ &quot;65 to 74 years&quot;, Age &gt;= 75 &amp; Age &lt;= 84 ~ &quot;75 to 84 years&quot;, Age &gt;= 85 ~ &quot;85 years and over&quot; ), levels = c(&quot;Under 5 years&quot;, &quot;5 to 9 years&quot;, &quot;10 to 14 years&quot;, &quot;15 to 19 years&quot;, &quot;20 to 24 years&quot;, &quot;25 to 34 years&quot;, &quot;35 to 44 years&quot;, &quot;45 to 54 years&quot;, &quot;55 to 59 years&quot;, &quot;60 to 64 years&quot;, &quot;65 to 74 years&quot;, &quot;75 to 84 years&quot;) ), age_6 = case_when( Age &lt; 5 ~ &quot;Under 5 years&quot;, Age &gt;= 5 &amp; Age &lt; 18 ~ &quot;5 to 17 years&quot;, Age &gt;= 18 &amp; Age &lt; 25 ~ &quot;18 to 24 years&quot;, Age &gt;= 25 &amp; Age &lt; 45 ~ &quot;25 to 44 years&quot;, Age &gt;= 45 &amp; Age &lt; 65 ~ &quot;45 to 64 years&quot;, Age &gt;= 65 ~ &quot;65 years and over&quot; ), Year = year(`MMWR Date`) ) %&gt;% group_by(Year, age_6) %&gt;% tally(name = &quot;Count&quot;) %&gt;% complete(fill = list(Count = 0)) %&gt;% filter(!is.na(age_6)) %&gt;% left_join( census_age, by = join_by(age_6 == Label, Year) ) %&gt;% mutate(&quot;Incidence&quot; = Count / Population * 100000, &quot;age_6&quot; = factor( x = age_6, levels = c(&quot;Under 5 years&quot;, &quot;5 to 17 years&quot;, &quot;18 to 24 years&quot;, &quot;25 to 44 years&quot;, &quot;45 to 64 years&quot;, &quot;65 years and over&quot;) )) gono_race &lt;- gono_filtered %&gt;% mutate( &quot;race_5&quot; = case_when( Race == &quot;White&quot; ~ &quot;White&quot;, Race == &quot;Black or African American&quot; ~ &quot;Black or African American&quot;, Race == &quot;Asian&quot; ~ &quot;Asian&quot;, str_detect(Race, &quot;,&quot;) ~ &quot;Two or more races&quot;, Race == &quot;Unknown&quot; | is.na(Race) ~ NA, .default = &quot;Some other race&quot; ), Year = year(`MMWR Date`) ) %&gt;% group_by(Year, race_5) %&gt;% tally(name = &quot;Count&quot;) %&gt;% complete(fill = list(Count = 0)) %&gt;% filter(!is.na(race_5)) %&gt;% left_join( census_raceth, by = join_by(race_5 == Label, Year) ) %&gt;% mutate(&quot;Incidence&quot; = Count / Population * 100000, &quot;race_5&quot; = factor( x = race_5, levels = c(&quot;Asian&quot;, &quot;Black or African American&quot;, &quot;White&quot;, &quot;Some other race&quot;, &quot;Two or more races&quot;) )) gono_city &lt;- gono_filtered %&gt;% mutate(Year = year(`MMWR Date`)) %&gt;% group_by(Year, City_guess) %&gt;% tally(name = &quot;Count&quot;) %&gt;% complete(fill = list(Count = 0)) %&gt;% filter(!is.na(City_guess)) %&gt;% mutate( &quot;Count&quot; = case_when( Count &lt;= 5 ~ NA, .default = Count ) ) 3.7.4 Graphing gonorrhea incidence by age group ggplot( gono_age, aes(x = age_6, y = Incidence, fill = as.character(Year)) ) + geom_col(position = position_dodge()) + scale_fill_brewer(palette = &quot;Set2&quot;) + labs( x = &quot;Age group&quot;, y = &quot;Cases per 100k population&quot;, fill = &quot;Year&quot; ) + theme_minimal() + ggtitle(&quot;Gonorrhea Incidence by Age Group in Wake County, 2019-2023&quot;) + theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot; ) 3.7.5 Graphing gonorrhea incidence by race ggplot( gono_race, aes(x = race_5, y = Incidence, fill = as.character(Year)) ) + geom_col(position = position_dodge()) + scale_fill_brewer(palette = &quot;Set2&quot;) + labs( x = &quot;Race&quot;, y = &quot;Cases per 100k population&quot;, fill = &quot;Year&quot; ) + theme_minimal() + ggtitle(&quot;Gonorrhea Incidence by Race in Wake County, 2019-2023&quot;) + theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot; ) 3.7.6 Graphing gonorrhea count by municipality ggplot( gono_city, aes( x = Count, y = fct_rev(City_guess), fill = fct_rev(as.factor(Year)) ) ) + geom_col(position = position_dodge()) + labs( x = &quot;Cases&quot;, y = &quot;Municipality&quot;, fill = &quot;Year&quot; ) + scale_fill_brewer(palette = &quot;Set2&quot;, guide = guide_legend(reverse = TRUE)) + theme_minimal() + ggtitle(&quot;Gonorrhea Count by Municipality in Wake County, 2019-2023&quot;) + theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot; ) 3.8 Final notes This analysis produced six graphs, which give useful information for conclusions. Risk of chlamydia and gonorrhea is highest by far for residents aged 18 to 24. Though there is discussion of high nursing home transmission of STIs, case data from 2019 to 2023 do not demonstrate a concern in the 65 years and over age group. Black and African American residents are at higher risk for chlamydia and gonorrhea, and both appear to be sharply increasing. White, Asian, and multiracial residents appear to be at low risk, while residents of other races (including American Indian/Alaska Native and Native Hawaiian/Pacific Islander) are at elevated risk. Raleigh accounts for most STI cases, and its cases are rising. Cases in most other municipalities are not trending in any particular direction, with some seeing a slight increase. This kind of analysis can be very illustrative, and it would likely benefit other Wake County programs. R makes the process of analyzing line list data in this way much faster and repeatable. The American Community Survey (ACS) is a survey tool from the United States Census Bureau. For 2018, 2019, 2021, and 2022, table DP05 (ACS Demographic and Housing Estimates) was used.↩︎ The Decennial Census is performed every ten years by the United States Census Bureau. For 2020, table DP1 (Profile of General Population and Housing Characteristics) was used.↩︎ "],["respiratory-viruses.html", "Section 4 Respiratory Viruses 4.1 Header content 4.2 Settings and setup 4.3 Importing data 4.4 Highlights slide 4.5 Graphing 4.6 Rendering and formatting 4.7 Final notes", " Section 4 Respiratory Viruses The Epidemiology Program at WCHHS, during flu season, publishes a bi-weekly update on respiratory viruses using data from the North Carolina Disease Event Tracking and Epidemiologic Collection Tool (NC DETECT), which collects emergency department case data and classifies reported syndromes. Three conditions are pulled from NC DETECT: influenza-like illness (ILI), COVID-like illness (CLI), and respiratory syncytial virus (RSV). Emergency department data can provide insight into community levels of disease, and it is particularly useful when other means of reporting are unavailable or inconsistent. This section walks through the process of automating the production of these bi-weekly reports in R. This process uses Quarto, which is an advanced implementation of RMarkdown, to generate a PowerPoint presentation. From within RStudio, R code can be executed, graphics can be rendered, and text can be written. Once Quarto (in RStudio) renders the presentation, the .pptx file can be manually edited, and a standard theme (such as Wake County’s preferred slide theme) can be applied in PowerPoint. If you are only looking for instructions on how to automatically generate the presentation, skip to rendering and formatting. 4.1 Header content Unlike previous projects in this presentation, where the format was essentially just a vehicle for delivery, the presentation format is essential to the project. Instead of libraries, then, we will start at the top: the RMarkdown header. --- title: &quot;Influenza, RSV and COVID-19 Bi-Weekly Update&quot; author: &quot;Wake County Health and Human Services&quot; format: pptx --- The header includes three elements: The title of the presentation, which will go on the title slide. The author of the presentation, which will go beneath the title. The presentation format, which should be pptx unless you are familiar with another supported format. We do not need to create a separate title slide below the header because the header will be used to generate the title slide. 4.2 Settings and setup Because this presentation’s code is intended to be infinitely reusable, a settings chunk is included at the top, where instructions are included for setting the dates of interest. ## Dates of interest: The MMWR Week range, in the current year, ## which you want to graph. Use year-month-day format. start_date &lt;- &quot;2024-05-05&quot; end_date &lt;- &quot;2024-06-01&quot; ## Comparison dates: The MMWR Week range, in the prior year, ## which you want to graph. Use year-month-day format. start_date_ly &lt;- &quot;2023-05-07&quot; end_date_ly &lt;- &quot;2023-05-28&quot; In this section, we set (in year-month-day format) the start and end dates for analysis. Dates for both the current year and the prior (comparison) year must be included, since weeks do not start on the same date. When all of these dates are Sundays, the code treats start_date and start_date_ly as the first dates for analysis, and it treats end_date and end_date_ly as the first day of the last week to be included in the analysis. Choosing any day except Sunday for the end dates will select the week they are in, so choosing Saturday as your end date will work as expected. Before running the presentation, files also need to be dropped into the folder. NC DETECT allows for line list exports, and these line lists are used for the presentation. Three files, named CLI.xlsx, ILI.xlsx, and RSV.xlsx, need to be added to the Automation folder, and they should include all cases between your chosen start_date_ly and your end_date. We’ll see later how the code filters out the cases between end_date_ly and start_date so they don’t interfere with the graphs. Once we’ve set the dates and are ready to continue running the presentation, the code will format the dates. We will also need to load the libraries. # Libraries suppressPackageStartupMessages(library(tidyverse)) suppressPackageStartupMessages(library(readxl)) # Date formatting start_date &lt;- ymd(start_date) end_date &lt;- ymd(end_date) start_date_ly &lt;- ymd(start_date_ly) end_date_ly &lt;- ymd(end_date_ly) As we have previously, we use tidyverse and readxl. One tidyverse package, called lubridate, will be helpful here as we format dates: the ymd() function informs R that the dates we chose before are dates in year-month-day format. 4.3 Importing data Next, we write a function to read and modify the NC DETECT data. This is a long one, and several mutate steps are used here to make sure the variables are modified and read in a useful order. Also note the use of %&gt;% (pipe) characters to order this function. Without piping, the functions would have to be nested with the last function on the outside, which would make this code practically unreadable. # Assign to `sesh_import` a function with one argument (x) and the following code sesh_import &lt;- function(x){ # Begin with the data, given to the function as an argument x %&gt;% # Mutate variables mutate( # Modify three variables from character type to date-time (year-month-day, hour-minute-second) type &quot;Arrival Date Time&quot; = ymd_hms(`Arrival Date Time`), &quot;(beta) ED Discharge DT&quot; = ymd_hms(`(beta) ED Discharge DT`), &quot;(beta) Hospital Discharge DT&quot; = ymd_hms(`(beta) Hospital Discharge DT`) ) %&gt;% # Mutate more variables mutate( # Create `Arrival`, which takes just the date information from `Arrival Date Time` &quot;Arrival&quot; = as_date(`Arrival Date Time`), # Calculate the epi week, starting on Sunday, when the case occurred &quot;MMWR Week&quot; = case_when( wday(Arrival) == 1 ~ Arrival, # If the arrival day was Sunday, use that day wday(Arrival) &gt; 1 ~ # If the arrival day was not Sunday... Arrival - days(wday(Arrival)) + 1, # ...determine the most recent Sunday .default = NA # If there is no arrival date, return NA ), # Calculate the epi year &quot;MMWR Year&quot; = year(`MMWR Week`), # Delete the arrival date time variable (it&#39;s not very useful) &quot;Arrival Date Time&quot; = NULL, # Put these variables at the beginning (before column 1) .before = 1 ) %&gt;% # Mutate more variables mutate( # Make `Patient Age` a numeric (not character) variable `Patient Age` = as.numeric(`Patient Age`), # Make `Patient Age Group` an ordered variable (factor) `Patient Age Group` = factor( # Keep the same values as the original dataset&#39;s (.) variable ($`Patient Age Group`) x = .$`Patient Age Group`, # Make the variable ordinal, and order its values this way levels = c(&quot;Infant (0 - 1)&quot;, &quot;PreSchool (2 - 4)&quot;, &quot;Elem. School (5 - 9)&quot;, &quot;Middle School (10 - 14)&quot;, &quot;High School (15 - 18)&quot;, &quot;College (19 - 24)&quot;, &quot;Young Adult (25 - 44)&quot;, &quot;Middle Aged (45 - 64)&quot;, &quot;Senior (65+)&quot;) ), # Make two more variables numeric - this will throw an error if data is unclean `Patient ZIP` = as.numeric(`Patient ZIP`), `Init Temp` = as.numeric(`Init Temp`), # Make Race and Ethnicity factors as well Race = factor( x = .$Race, levels = c(&quot;Asian&quot;, &quot;Black&quot;, &quot;White&quot;, &quot;Other&quot;) ), Ethnicity = factor( x = .$Ethnicity, levels = c(&quot;Hispanic&quot;, &quot;Not of Hispanic Origin&quot;, &quot;Unknown&quot;) ) ) %&gt;% # Create an age group variable using `Patient Age` and order it mutate(`Age Group` = factor( x = case_when( `Patient Age` &lt;= 4 ~ &quot;(00 - 04) Infant/Toddler&quot;, `Patient Age` &gt;= 5 &amp; `Patient Age` &lt;= 17 ~ &quot;(05 - 17) School-Age&quot;, `Patient Age` &gt;= 18 &amp; `Patient Age` &lt;= 24 ~ &quot;(18 - 24) College&quot;, `Patient Age` &gt;= 25 &amp; `Patient Age` &lt;= 49 ~ &quot;(25 - 49) Young Adult&quot;, `Patient Age` &gt;= 50 &amp; `Patient Age` &lt;= 64 ~ &quot;(50 - 64) Middle Aged&quot;, `Patient Age` &gt;= 65 ~ &quot;(65+) Senior&quot;, .default = &quot;Unknown/Missing&quot; ), levels = c(&quot;(00 - 04) Infant/Toddler&quot;, &quot;(05 - 17) School-Age&quot;, &quot;(18 - 24) College&quot;, &quot;(25 - 49) Young Adult&quot;, &quot;(50 - 64) Middle Aged&quot;, &quot;(65+) Senior&quot;, &quot;Unknown/Missing&quot;) )) %&gt;% # Filter out data that isn&#39;t in the specified epi week range filter((`MMWR Week` &gt;= start_date &amp; `MMWR Week` &lt;= end_date) | (`MMWR Week` &gt;= start_date_ly &amp; `MMWR Week` &lt;= end_date_ly)) %&gt;% # Modify epi year values to keep seasons together (see note) mutate( &quot;modified&quot; = case_when( year(end_date) - year(start_date) == 1 &amp; str_detect(`MMWR Week`, &quot;-08-|-09-|-10-|-11-|-12-&quot;) ~ TRUE, .default = FALSE ), &quot;MMWR Year&quot; = case_when( year(end_date) - year(start_date) == 1 &amp; str_detect(`MMWR Week`, &quot;-08-|-09-|-10-|-11-|-12-&quot;) ~ `MMWR Year` + 1, .default = `MMWR Year` ) ) } There is a lot here! There are two main things that need more explanation than the code comments: factors and modifying epi year values. 4.3.1 Factors Factors are ordered categorical variables. We use them when we have a variable with text values that have an inherent (non-alphabetical) order. A good example is Patient Age Group: if we left it as a regular character variable, it would be ordered like this: ## [1] &quot;College (19 - 24)&quot; &quot;Elem. School (5 - 9)&quot; &quot;High School (15 - 18)&quot; ## [4] &quot;Infant (0 - 1)&quot; &quot;Middle Aged (45 - 64)&quot; &quot;Middle School (10 - 14)&quot; ## [7] &quot;PreSchool (2 - 4)&quot; &quot;Senior (65+)&quot; &quot;Young Adult (25 - 44)&quot; But we don’t want them to be alphabetical, because that doesn’t make sense for the data. A factor allows us to take data (given in the x argument) and order it according to a list or vector we create (given in the levels argument). If you are familiar with SAS, this is very similar to coding variables as numeric and using PROC FORMAT to cover the underlying number, except that R never requires you to remember or use the number directly. 4.3.2 Modifying the epi year Because flu season runs from fall to spring, our line graphs need to span the gap between December and January. The best way to do this is to tweak the epi year, so that (as an example) the 2023-2024 season will appear on the graph as a continuous line for 2024. We only need this feature to activate when the following conditions are met: start_date and end_date are in different years. The case occurred in or after August, which will always catch the beginning of fall. We can evaluate the first condition by just subtracting the years. For the second condition, we use str_detect to check the month, which will always be between the two dashes in year-month-day format. If these conditions are met, we adjust the year up by one to keep the lines continuous, and we also set a new modified variable to TRUE so we know this case was affected. More work is needed to solve this problem, which we’ll see in the graphing code later. 4.3.3 Reading the files Finally, we actually read the files using the function we created above. # Read files ILI &lt;- read_xlsx(&quot;ILI.xlsx&quot;) %&gt;% sesh_import() RSV &lt;- read_xlsx(&quot;RSV.xlsx&quot;) %&gt;% sesh_import() CLI &lt;- read_xlsx(&quot;CLI.xlsx&quot;) %&gt;% sesh_import() We use read_xlsx from the readxl package to read each file and pipe the data into sesh_import above. Now, our data is imported. 4.4 Highlights slide For the presentation, all code is invisible, because the R code chunks in our Quarto document include the option echo = FALSE (unlike this presentation, where we want to see the code). Because code is invisible, everything between the header and now is performed, but it isn’t displayed on the slides. However, we do want to show some content. We want to create a Highlights slide, where an epidemiologist can include main takeaways from the data collected for the presentation. We want space for content to be added to the PowerPoint after it’s generated, but nothing here needs to be run in R, so we can just use plain text in Markdown syntax. # Highlights - Influenza Like Illness (ILI) - Content here - Respiratory Syncytial Virus (RSV) - Content here - COVID-19 - Content here The # creates a first-level heading, which in the context of a presentation becomes the title of a new slide. If we wanted subheadings, we could use ##. Then, we use - and indentations to create unordered bullets and sub-bullets. Content can be edited on the .qmd document, but it is probably more useful and efficient in this case to do it directly on the PowerPoint after rendering. RMarkdown syntax is very powerful, and very little of it is used for this specific presentation, so see the website for details. You can also see the Resources and Preventive Measures sections of the Quarto presentation document for more examples. 4.5 Graphing Now, we can start to graph the data we’ve pulled. I’ll include only the code and graphs for influenza-like illness here, because each disease’s graphs work the same way, but the .qmd file on the SharePoint generates graphs for ILI, RSV, and CLI. For graphing, as elsewhere in this presentation, we use ggplot2 from the tidyverse. 4.5.1 ILI counts by week To create this graph, we need to do a few things: Select the ILI data. Extract just the month and day from the epi week fields to save space. Additionally, when the graph would straddle January 1 of any year, modify dates before January 1 so they appear to the left of dates after January 1. Group cases by epi week and year, then count cases in each group. Plot a line graph with two lines, one for each year, showing the counts. We complete those steps with this code: # 1. Select the `ILI` data ILI %&gt;% # 2. Extract just the month and day from `MMWR Week` mutate( `MMWR Week` = case_when( modified == FALSE ~ paste( sprintf(&quot;%02d&quot;, month(`MMWR Week`)), sprintf(&quot;%02d&quot;, day(`MMWR Week`)), sep=&quot;-&quot; ), # 2a. Modify dates before 1/1 to appear to the left modified == TRUE ~ paste( &quot;&quot;, sprintf(&quot;%02d&quot;, month(`MMWR Week`)), sprintf(&quot;%02d&quot;, day(`MMWR Week`)), sep=&quot;-&quot; ) ), ## Modify the year to be discrete rather than continuous (for display purposes) `MMWR Year` = as.character(`MMWR Year`) ) %&gt;% # 3. Group cases by epi week and year, then tally cases group_by(`MMWR Year`, `MMWR Week`) %&gt;% tally(name = &quot;Count&quot;) %&gt;% # 4. Plot a line graph ggplot(aes(x = `MMWR Week`, y = Count, color = `MMWR Year`, group = `MMWR Year`)) + geom_line(linewidth = 2) + ylim(0, NA) + labs( x = &quot;Week&quot;, color = &quot;Year&quot; ) + scale_color_brewer(palette = &quot;Set2&quot;) + theme_minimal() + ggtitle(&quot;ILI Counts by Week&quot;) + theme( legend.position = &quot;bottom&quot;, plot.title = element_text(hjust = 0.5) ) We start by piping ILI forward to the next function. Then, there are two scenarios: For cases where MMWR Year was not modified, we extract the month and day (using sprintf(), which gets and reformats variable values) from MMWR Week, then paste() them together with a dash in between. For cases where MMWR Year was modified, we do the same thing, except we also add a dash in front of the month by including \"\" (which is a blank string) in our paste() before the month. R will alphabetize the dash before numbers, so December will appear before January. In our mutate(), we also modify the epi year to be a character variable, which lets us deal with it as a discrete variable instead of a continuous one. Next, as we’ve done for previous graphs, we group cases by their epi week and year and tally the groups, leaving us with graphable data. Finally, we plot: We use aes() to define the variables for our x-axis, y-axis, and line coloring. We choose a line graph with geom_line() and set its thickness (2). We set the y-axis limits with ylim(), where we want the graph to go from 0 to ggplot’s chosen maximum, which we request with NA. We change the x-axis and legend titles. We choose our coloring scheme, in this case from RColorBrewer’s palettes. We set our ggplot theme. We set a plot title with ggtitle(). We modify the legend position and the plot title alignment by changing specific theme elements. While the order of some of these elements is flexible, some are not. For instance, if theme() came before theme_minimal(), any settings we specified in theme() would be reset. When writing your own graph code, you will need to use trial and error to determine the best order for your use case. That leaves us with a line graph of the counts, compared between years. Below is a sample generated for the last report of the 2023-2024 flu season. 4.5.2 ILI counts by age group To graph counts by age group, we need to do a few things differently. We no longer need a comparison year, so we will filter and keep only data for only the current season. For grouping, we’ll substitute age group in for epi year, since we are not comparing years. Because cases do not always span all demographics, we need to fill in zeroes for weeks when an age group does not have any cases. When plotting, our lines will be colored according to age group rather than year. This code generates the necessary graph. Code is spaced for easier viewing, and comments are included where there are differences from the counts by year graph. ILI %&gt;% # 1. Filter and keep only current season data filter(year(`MMWR Week`) == year(start_date) | year(`MMWR Week`) == year(end_date)) %&gt;% mutate( `MMWR Week` = case_when( modified == FALSE ~ paste( sprintf(&quot;%02d&quot;, month(`MMWR Week`)), sprintf(&quot;%02d&quot;, day(`MMWR Week`)), sep=&quot;-&quot; ), modified == TRUE ~ paste( &quot;&quot;, sprintf(&quot;%02d&quot;, month(`MMWR Week`)), sprintf(&quot;%02d&quot;, day(`MMWR Week`)), sep=&quot;-&quot; ) ), `MMWR Year` = as.character(`MMWR Year`) ) %&gt;% # 2. Group by age and epi week group_by(`Age Group`, `MMWR Week`) %&gt;% tally(name = &quot;Count&quot;) %&gt;% # 3. Fill in zero when there are no cases in an age group for a week ungroup() %&gt;% complete(`MMWR Week`, `Age Group`, fill = list(Count = 0)) %&gt;% # 4. Use age group to color lines ggplot(aes(x = `MMWR Week`, y = `Count`, color = `Age Group`, group = `Age Group`)) + geom_line(linewidth = 2) + ylim(0, NA) + labs(x = &quot;Week&quot;, color = NULL) + scale_color_brewer(palette = &quot;Set3&quot;) + ggtitle(&quot;ILI Counts of ED Visits by Age Group&quot;) + # The title is changed here theme_minimal() + theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot;, legend.text = element_text(size = 7), # Because there are so many legend items, the size legend.title = element_text(size = 9) # of legend text is changed to fit on the graph. ) When creating multiple graphs with the same data, it is often easier to code the first graph and make modifications rather than coding each graph from scratch. Re-using code is efficient and consistent! 4.5.3 ILI proportions by age group For the bi-weekly presentation, we also want to calculate the proportion of cases in each age group rather than just the counts. For this, we mostly recycle the counts graph code, but with a few modifications: We calculate the total number of cases each week by grouping the tallies and creating a Total variable. We calculate the proportion of weekly cases made up by each age group by dividing the Counts column by our new Total column. When graphing, we change the y-axis from counts to proportions. This code generates the proportions graph. Again, see code comments to find where these modifications were made. ILI %&gt;% filter(year(`MMWR Week`) == year(start_date) | year(`MMWR Week`) == year(end_date)) %&gt;% mutate( `MMWR Week` = case_when( modified == FALSE ~ paste( sprintf(&quot;%02d&quot;, month(`MMWR Week`)), sprintf(&quot;%02d&quot;, day(`MMWR Week`)), sep=&quot;-&quot; ), modified == TRUE ~ paste( &quot;&quot;, sprintf(&quot;%02d&quot;, month(`MMWR Week`)), sprintf(&quot;%02d&quot;, day(`MMWR Week`)), sep=&quot;-&quot; ) ), `MMWR Year` = as.character(`MMWR Year`) ) %&gt;% group_by(`Age Group`, `MMWR Week`) %&gt;% tally(name = &quot;Count&quot;) %&gt;% # 1. Group by epi week and total weekly cases group_by(`MMWR Week`) %&gt;% mutate(&quot;Total&quot; = sum(Count)) %&gt;% # 2. Calculate proportions ungroup() %&gt;% mutate(&quot;Proportion&quot; = Count / Total) %&gt;% complete(`MMWR Week`, `Age Group`, fill = list(Proportion = 0)) %&gt;% # 3. Graph proportions instead of counts ggplot(aes(x = `MMWR Week`, y = `Proportion`, # Change the y-axis values here color = `Age Group`, group = `Age Group`)) + geom_line(linewidth = 2) + ylim(0, NA) + labs(x = &quot;Week&quot;, color = NULL) + scale_color_brewer(palette = &quot;Set3&quot;) + ggtitle(&quot;ILI Proportions of ED Visits by Age Group&quot;) + # Change the plot title theme_minimal() + theme( plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot;, legend.text = element_text(size = 7), legend.title = element_text(size = 9) ) Now we have a graph of proportions. Though the proportions and counts of ILI for these dates are very similar, that will not always be the case, so don’t expect the counts and proportions graphs to be identical every time. 4.6 Rendering and formatting Now that the graphs are complete, we need to generate (render) and apply formatting to the presentation. Before you start, make sure you have replaced the line lists in the Automation folder. You will need to download three line lists: one for CLI (CLI_No_Flu), one for ILI (ILI), and one for RSV (RSV (ICD-9/10-CM or keyword)). When getting the line lists, the “date from” should be the first Sunday of the date range for the prior season, and the “date to” should be the last Saturday of the date range for the current season. First, open the Automation R project in the Automation folder. When RStudio opens, make sure Presentation.qmd is open. If it is not, you can select it in the bottom right part of the screen. Then, edit your dates. start_date and end_date should be the date range (probably Sunday to Saturday) in which you would like to graph cases for the current season. start_date_ly and end_date_ly (ly stands for “last year”) should be the date range that will be graphed from the prior season as a comparison. In general, start_date_ly should be a Sunday and end_date_ly should be a Saturday. Next, click “Render” to generate the presentation. Any errors will appear in the console at the bottom-left. A browser window may open, and the presentation may download. You can delete the file in your downloads and close the browser, because the presentation will appear in your Automation folder. Click Presentation.pptx at the bottom right of RStudio (or open it from the Automation folder in Windows Explorer). You can now apply the official county theme to the presentation. Under the Design tab, click the dropdown option for themes, then click “Browse for Themes…”. The theme you need is already saved to the Automation folder. Navigate to the folder, then open wake_theme.thmx. Now the theme is applied, and you can make any necessary changes to the text (such as the Highlights page). 4.7 Final notes Automating presentations in R can be very useful when similar reports need to be produced on a regular basis. Quarto makes this process simple, as you can generate an entire presentation from just one RMarkdown document, and R can be used to process and analyze your data the same way each time. RStudio also includes the ability, at no cost, to make several other types of projects using the same syntax and environment. For example, this web presentation was generated with Bookdown, which we’ll talk about briefly in the next section. "],["bookdown.html", "Section 5 Bookdown 5.1 File structure 5.2 Bookdown package", " Section 5 Bookdown Bookdown is a format just like what you see now: a reader page with content and view options with a navigator outline on the left. It’s very useful for reference documentation (I frequently use manuals generated in Bookdown, like the R Graphics Cookbook) but it can also be used in cases like this presentation, where you want to display R code in a nice, readable way, run it in the document, and surround it with explanation. 5.1 File structure When you open the In-Service Bookdown folder, you’ll see all the content used to generate this presentation. The settings files _bookdown.yml and _output.yml, which are mostly auto-generated. The RMarkdown files I wrote, including index.Rmd and each of the numbered .Rmd files. The .Rproj file you should open if you want to view or work with the project’s raw code. The various (deidentified) data files used to generate the content of the presentation, including census_18-22.csv, wake_zips.csv, and the files in Tables. The screenshots taken for the Respiratory Viruses section under Images. The Notifiables Table webpage created for the 2024 CD Report. HTML files and associated items, which are mostly in _book. Also in the main folder is the Data folder, which contains all identified line list data used for this presentation. It is accessible on the SharePoint, but is not exported so I don’t take confidential data with me when I leave. 5.2 Bookdown package Bookdown is not included with RStudio. To get it, run install.packages(\"bookdown\") in your RStudio console. Everything you need to know to use Bookdown can be found in the Bookdown documentation. Once you have the package installed, try it out! Bookdown comes with lots of useful instructions and examples to get you started. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
